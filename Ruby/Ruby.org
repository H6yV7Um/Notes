#+TITLE: Ruby编程语言

动态语言 完全面向对象

=true= =false= =nil=  

=0= 是 =true=

双引号中位于分界符 /#{/ 和 /}/ 之间的表达式，将调用其 =to\_s= 方法转成字符串。

类和模块都是开放的，可在运行时修改和扩展。

如果对象 /obj/ 有一个 /x=/ 的方法， 则 /obj.x=(1)/ 与 /obj.x=1/ 。

一般省略函数调用的圆括弧，尤其是无参方法。

=empty?= 方法会测试数据结构是否包含元素。

方法名中含有字符 /!/ ， 表明该方法会修改原对象。

全局变量以 /$/ 为前缀，实例变量以 /@/ 为前缀，类变量以 /@@/ 为前缀。

=1..3 #[1,2,3]=，     =1...3 #[1,2]=

字符串是可变的，[]= 去改变字符串中的字符， /<</ 字符串尾部追加。

/ri/ 是Ruby的文档查看器，后接类名，模块名，方法名，若一个类定义了同名的类方法和实例方法，则用 /::/ 引用类方法，用 /#/ 引用实例方法。

标识符由字母、数字、和下划线组成，但不能以字母开头。 以26个大写字母开头的标识符为常量。模块名和类名也必须以大写字母开头。 
局部变量以下划线或者小写字母开头。

默认将换行符看作是语句的总结符，只有在一行代码中放入多条语句时，才使用分号分割语句。可用 /\/ 避免自动总结语句。

把相互关联的类及独立于那些类的方法组成模块。

代码块既可以用 /{/ 和 /}/ 界定， 也可以用 /do/ 和 /end/ 界定。

引用一个未被赋值的类变量，会抛出 =NameError= ; 引用一个未被初始化的实例变量，返回 /nil/ ; 引用一个未被初始化的全局变量，返回 /nil/ 。

表达式中的 /::/ 表示常量引用。例， =::ARG= (=Object::ARGV=)

只有在真正被赋值后，常量才存在; 对变量赋值时，即使并未真正执行赋值，变量就存在了。

#+BEGIN_SRC ruby
a[0] # a[](0)
x+y # x.+(y)
o[x,y] = z # o[]=(x,y,z)
o[x] -= 2 # o[]=(x, o.[](x)-2)
#+END_SRC

在对象外，实例变量是永不可见的，且实例变量名永不会被对象限定修饰。

表达式 /x/, 既可以是局部变量 /x/ ， 也可以是 /self/ 对象的一个方法 /x/ ， 为消除此二义性， Ruby将
该标识符当作局部变量来处理，条件是在这之前有变量的复制操作（即使该操作未执行）。

对已存在的常量赋值，只会导致一个警告; 在方法内是不允许对常量赋值的; 因为只有在真正执行了对常量的赋值后， 
常量才会存在，故不存在未初始化的常量。

Ruby对属性或数组元素的赋值，其实是对方法调用的简写。

并行赋值
#+BEGIN_SRC ruby
x, y, z = [1, 2, 3] # x, y, z = 1, 2, 3
x, = [1, ] # x=1
x, y, z = 1, 2 # x=1; y=2; z=nil
x, y, z = 1, *[2, 3] # x, y, z = 1, 2, 3
x, *y = 1, 2, 3 # x=1; y=[2, 3]
*x, y = 1, 2, 3 # x=[1,2]; y=3
x, y, *z = 1, *[2, 3, 4] # x=1; y=2; z=[3, 4]
x, (y, z) = 1, [2,3] # x, y, z = 1, 2, 3
a, b, c, d = [1, [2, [3, 4]]] # a=1; b= [2, [3, 4]]; c=d=nil
a, (b, (c, d)) = [1, [2, [3, 4]]] # a=1; b=2; c=3; d=4
#+END_SRC

类中可以定义各个操作符（但不是全部）的含义，例如， /</ 、 /&/ 、 /+/ 、 /！/ 等等。
/-/ 和 /+/ 既可以作为一元操作符， 也可以作为二元操作符。 作为一元操作符时，对应的方法名分别为 /-@/ 、 /+@/ 。

一个类在定义了 /<=>/ 操作符，并混入了 =Comparable= 模块后， 就自动有了 /</ 、 /<=/ 、 />/ 、 />=/ 、 /==/ 。

就布尔操作而言， /false/ 和 /nil/ 都被认为是 /false/ ， 其他如 /0/ 、 "" 、 /[]/ 、 /{}/ 都被认为是 /true/ 。
 
