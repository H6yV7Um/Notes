* Bitcoin Developer Guide
Only the 80 bytes block header is hashed for PoW, so including a large volume of transaction 
data in a block does not slow down hashing, but only requires the recalculation of the 
ancestor hashes in the merkle tree. 

The hash of a block header is below the target threshold.

Each transaction is hashed, and the hashes are then paired, hashed, paired again, and hashed 
again until a single hash remains, that is the merkle root, which is stored in block header.

Each block contains the hash of the previous block's header, chaining the blocks together.

Transactions are also chained together through its inputs and outputs which are tied to TXIDs 
,that is the hashes of signed transaction.

Since multiple blocks can have the same height during a block chain fork, block height should 
not be used as a globally unique identifier. Instead, blocks are usually referenced by the 
hash of their header.

The first one of transactions in a block must be a *coinbase transaction*, also called a 
*generation transaction*, which should collect and spend the block reward(comprised of a 
block subsidy and any transaction fees paid by transactions in the block). The UTXO of a 
coinbase transaction cannot be spent for at least 100 blocks to prevent a miner from spending 
the transaction fees and block reward from a block that may later be determined to be stale(
and therefore the coinbase transaction detroyed) after a block chain fork.

Blocks are not required to include any non-coinbase transaction, nut miners almost always do 
include additional transactions in order to collect their transaction fees.

All transactions, including coinbase transaction, are encoded into blocks in binary 
rawtransaction format. The rawtransaction format is hashed to create the TXID. If there are 
an odd number of TXIDs, the TXID without a partner is hashed with a copy of itself.

The merkle tree allows clients to verify for themselves that a transaction was included in a 
block by obtaining the merkle root and neighbor intermediate hashes of the transaction.

Hard fork or soft fork may happen when upgrading the bitcoin system. Hard fork happens when 
non-upgraded bitcoin nodes cannot verify the new block generated by the upgraded nodes. 
Soft fork happens when non-upgraded bitcoin nodes can verify the new blocks generated by 
upgraded nodes. New blocks generated by non-upgraded nodes could be verified by both 
non-upgraded nodes and upgraded nodes.

In Bitcoin Core, if a non-upgraded node receives block chain headers demonstrating at least 
six blocks more PoW than the best chain it considers valid, the node reports Hard Fork 
through a warning in =getnetworkinfo= RPC results and runs command =-alertnitify= if set. 
For a Full node, if the block or transaction version numbers seen in several recent blocks 
are higher than the version number the node uses, the node reports Hard Fork as above.  

P2PKH(Pay to Public Key Hash): used by most transaction except coinbase transaction
- Pubkey script
  A output in transaction contains amount in satoshis and pubkey script.
  The output is identified by previous transaction txid and the output index.
  pubkey script: =OP_DUP OP_HASH160 <PubkeyHash> OP_EQUALVERIFY OP_CHECKSIG= .
  Anyone who can satisfy the pubkey script can spend up to the amount of satishis.
- Signature Script
  It provides data to satisfy the pubkey script.
  The data includes the spender's unhashed public key and signature with his private key.
  The data signed involves previous transaction txid, output index, previous pubkey script, 
  pubkey script generated by spender with hashed receipt's public key.
- P2PKH script validation
  concat signature script and pevious pubkey script, the get 
  =<signature> <unhashed pubkey> OP_DUP OP_HASH160 <PubkeyHash> OP_EQUALVERIFY OP_CHECKSIG= 
  unhashed pubkey is copied and hashed, then compared with PubkeyHash, if they are identical, 
  =OP_CHECNSIG= is executed to verify the signature with the unhashed pubkey, if success, the 
  spender can spend the amount of sotishis in previous transaction's output.

P2PK(Pay to Public Key): mainly used in coinbash transaction 
- Pubkey script 
  =<unhashed Pubkey> OP_CHECKSIG=
- Signature script
  =<signature>=
- validation
  =<signagure> <unhashed PubKey> OP_CHECKSIG=
 
Multisig: multiple signature is required to spend a UTXO.
A P2SH multisig with 2-of 3(at least 2 signatures must match the 3 public key)
#+BEGIN_SRC example
Pubkey script: <OP_2> <A pubkey> <B pubkey> <C pubkey> <OP_3> OP_CHECKMULTISIG
Signature script: OP_0 <A sig> <C sig> 
Redeem script: <signature script> <Pubkey script>
#+END_SRC  
Notice,
- opcodes OP_1 through OP_16 correspond to number 1 through 16
- OP_0 is reuqired because OP_CHECKMULTISIG consumes one more value than OP_2 indicated.
- Signatures in signature script must be in the same order as the pubkey script.

P2SH(Pay to Script Hash)
A redeem script hash is created by receipt, and given to spender. 
Spender put the hash into the pubkey script, that means, pay to the redeem script hash. 
When the receipt above want to spend the amount of sotishis, he provides his signature along 
with full redeem script in signature script, the p2p network ensures the hash of full redeem 
script equals to that in pubkey script in previous transaction output, if success, run 
redeem script.
#+BEGIN_SRC example
Redeem script: <OP_2> <A pubkey> <B pubkey> <C pubkey> <OP_3> OP_CHECKMULTISIG
Pubkey script: OP_HASH160 <Hash160(redeemscript)> OP_EQUAL
Signature Script: <sig> [sig] [sig...] <redeemscript>
#+END_SRC
Usually, bitcoin address is generated from Hash160(public key) with Base58 encoding, similarly,
Hash160(redeemScript) can be compiled to a bitcoin address(prefix with 3) with Base58 encoding.

OP_RETURN 
Null data transaction addes arbitrary data to a provable unspendable pubkey script that full 
nodes do not have to store in their UTXO database. It allows null data output up to the maximum 
allowed pubkey script size of 10,000 bytes if it follows all other rules, other rules like, 
- only a single null data output and must pay exactly 0 satoshis.
- the number of data push
  for 0.9, 0.10 and 0.11, only allow a single data push.
  after 0.12, any number of data push. 
- the number of bytes in a single data push
  40bytes for 0.9 and 0.10, 80bytes for 0.11, 83bytes for 0.12.

Signature Hash Types indicate a signer which part of a transaction to sign to protect those 
parts from modification. 
=SIGNHASH_ALL=, by default, signs all inputs and outputs.
=SIGHASH_NONE=, signs all of inputs but none of outputs to allow anyone to change where the 
satishis are going.
=SIGHASH_SINGLE=, the only output signed is the one correspond to this input to ensure 
nobody can change your part of transaction but allow others to change their part of 
transaction.
=SIGNHASH_ALL|SIGNHASH_ANYONECANPAY=, sign all of the outputs but only one input to 
allow anyone ti add/remove other inputs, and others can not change where sotishis go.
=SIGNHASH_NONE|SIGNHASH_ANYONECANPAY=, sign only one input to allow anyone to add/remove 
other inputs/outputs.
=SIGNHASH_SINGLE|SIGNHASH_ANYONECANPAY=, sign one input and its corresponding output to allow 
anyone to add/remove other inputs.

Transaction's locktime(called nLockTime) is signed by all signature hash types. The locktime 
indicates the earliest time a transaction can be added to the block chain, that gives the 
signer a chance to change his minds by creating a new non-locktime transaction. Due to that 
P2P network allow block time to be up to 2 hours ahead of real time, that means, a locktime 
transaction can be added to block chain up to 2 houts before its time lock officially expires,
so attempt to cancel a transaction should be made a few hours(>2hours) before. The only 
purpose of transaction's sequence number is to enable/disable locktime, to enable locktime, 
set it to zero, to disable locktime, set it to 0xffffffff.

Transaction pay fees based on the total byte size of the signed transaction. To broadcast a 
transaction, a minimum fee is reuqired after bitcoin core 0.9. Each block, firstly, reserves 
a high-priority area(size can be set) for high-priority transactions which spend satoshis 
that have not moved for a long time, then all other transactions are added based on fee per 
byte. 

For both privacy and security, it discourage users from reusing public key or address, if an 
application needs to provide a fixed URI to which payments should be sent, pls see URI section.

Transaction Malleability
Since signature script does not sign itself, attackers can make non-functional modifications 
to a transaction without rendering it invalid, but change the computed hash of the transaction, 
and introduce a problem when a output of the transaction is spent before the transaction is 
added to the block chain. To reduce transaction malleability, new transaction should not 
depend on previous transaction which has not been added to the block chain, and, a transaction 
should be tracked by the UTXOs it spends as inputs because they cannot be changed without 
invalidating the transaction.

Full Service Wallets
- generate private key, derive the corresponding public key, distribute public key
- monitor for outputs spent to public key
- create and sign transaction, broadcast the signed transaction

Network Wallet
- get parent public key
- derive child public key from parent public key, and distribute it
- monitor for outputs spent to those public keys
- create unsigned transaction, and transfer it to signing-only wallet
- broadcast signed transaction

Signing-only Wallet, like, offline wallet and hardware wallet
- create a parent private key, and transfer corresponding public key to network wallet
- receive unsigned transaction from network wallet, and give it back to network wallet

To make copying of private key(256bits number) less prone to error, WIF(Wallet Import Format) 
could be used. WIF uses Base58Check encoding on private key. To get WIF of private key, 
- add 0x80 as prefix for mainnet address or 0xef for testnet address
- append 0x01 if the private key was used to generate compressed public key, otherwise, no append.
- append the first 4 bytes of double SHA-256 of private key with prefix above and tail above
- convert byte string above to Base58 string using Base58Check encoding

Public key represent a point on a particular Elliptic Curve, while private key is random 256 
bits number, public key can be compressed by dropping the Y coordinate, that is compressed 
publick key. Uncompressed public key stat with 0x04; compressed public key begin with 0x03 or 
0x02. For the private key to be used with compressed public key, it has 0x01 appended as 
describes above.

Hierarchucal Deterministic Key takes advantage of ECDSA public key creation function =point()=,
which is =privatekey*G=, and =G= is a contant point on Elliptic Curve used in Bitcoin, 
moreover, =point((parent_private_key+i)%G)= equals to =parent_public_key+point(i)=, =i= is a 
predictable sequence of integer value. In practice, a random seed is introduced, that is 
called chain code, and steps for HD key derivation
- one way hash
  =HMAC-SHA512(256bit parent chaincode, 256bit uncompressed parent public key, index number)=
  the public key and the chain code together are called extended key.
- new child chain code
  that is, 256bit on the right side of the hash above
- child private key
  =(parent private key + 256bit on left hand of hash above)%G=
- child public key
  =point((parent private key + 256bit on left hand of hash above)%G)=, that is 
  =parent public key + point(256bit on left hand of hash above)=

If an attacker gets a extended keys, he can generate all chain codes, moreover, if he get 
a child, or further-descended private key, he can generate all private keys descending from 
that private key, perhaps worse, if he knows the parent chain code of that private key, he 
can recover the parent private key of that private key. Hardened keys is to fix those problem.
Hardened key derivation: 
- =HMAC-SHA(256bit parent chaincode, 256bit parent private key, index number)=
- new child chain code
  that is, 256bit on the right side of the hash above
- child private key
  =(parent private key + 256bit on left hand of hash above)%G=
- child public key
  =point(child private key)=
Notice, child public key cannot be created using parent public key!!! This makes hardened 
key derivation much less useful than normal HD key derivation, so hardened key derivation 
only apply to the master private key in Wallet.

The index number used in normal HD key derivation is from 0x00 to 0x7fffffff; the index 
number used in hardened key derivation is from 0x80000000 to 0xffffffff. The first normal 
key(0x00) is 0; the first hardened key(0x80000000) is 0'. "m" represents private key; "M" is 
for public key. Example, "m/0'/0/122'" refers to 123ed hardened private key of the 1st normal 
child of the 1st hardened child of master private key.

Operating Modes
* Bitcoin Developer Reference
** Bitcoin Core API
RPC accept and return the byte-wise reverse of hashes, example, hash of mainnet 300,000 
block's header is =5472...0000=, then previous-header-hash field of mainet 300,001 block 
header is =5472...0000=, but =getblock= RPC should use =0000...7254= to get block 
information. Byte-wise reverse also apply to TXID and merkle roots.

For P2PKH hash or P2SH hash, RPCs use internal byte order.
 
RPCs which return raw results, like =getrawtransaction=, always display hashes as they appear 
in blocks(internal byte order).

RPC interface for admin tasks, wallet operation, and queries about network and block chain 
data. RPC is disabled by default for =bitcoin-qt=. RPC is enabled by default for =bitcoind=. 

To use RPC, =rpcpassword= should be set in =bitcoin.conf= or with =-rpcpassword= program 
argument. =bitcoin-cli= is a C++ RPC client, locates in =bin= directory alongside =bitcoind= 
and =bitcoin-qt=, and it can be used as a CLI. 

Bitcoin-QT on Mac does not ship a bitcoind, but you can use curl instread, like, 
=curl --user uname --data-binary '{"id":"t0","method":"getinfo","params":[]}' http://127.0.0.1:8332/=.

For HTTP POST requests, RPC service listens on port 8332 in mainnet mode or 18332 in testnet 
or regtest mode. Authentation is implemented using HTTP basic authentication. RPC request 
must include a =Content-Type= header set to =text/plain= and a =Content-Length= header set 
to the size of the request body. The HTTP POST data of a request must be a JSON object with 
the format {"jsonrpc":1,"id":"","method":"getblock","params":[]}, =jsonrpc=, =id= are optional.
Response is in format of {"error":null/object,"code":123,"message":"","id":"","result":anytype},
=code= and =message= are defined in =rpcprotocol.h=, notice, =bitcoin-cli= will transform the 
raw response to make it more human-readable.

RPC interface supports batch requests while =bitcoin-cli= does not.
 
 
** P2P Network
All P2P occurs entirely on TCP.

| Network | Default Port | Start String |  Max nBits |
|---------+--------------+--------------+------------|
| Mainnet |         8333 |   0xf9beb4d9 | 0x1d00ffff |
| Testnet |        18333 |   0x0b110907 | 0x1d00ffff |
| Regtest |        18444 |   0xfabfb5da | 0x207fffff |

Regtest is a local testing environment where developers can control block generation.

To use testnet, use the argument =-testnet= with =bitcoin-cli=, =bitcoind= or =bitcoin-qt=.

** ZeroMQ
It bases on TCP connection, inter-process communication, and shared-memory, and provides 
various msg-oriented semantics such as pub/sub, req/tsp, and push/pull.

No authentication, No two-way protocol, subscribers should validate the received data since 
it maybe out of date, incomplete or even invalid. Subscribers receive transactions and blocks 
all-at-once and do not need to implement any sort of buffering or reassembly. The 0MQ port 
is exposed only to trusted entities.

ZeroMQ sockets are self-connecting and self-healing.

The following notifications are supported,
- zmqpubhashtx=address
- zmqpubhashblock=address
- zmqpubrawtx=address
- zmqpubrawblock=address

The socket type is PUB and the address must be a valid 0MQ socket address. The same address 
can be used in more than notification.

#+BEGIN_SRC sh
bitcoind -zmqpubhashtx=tcp://127.0.0.1:28332 -zmqpubrawtx=ipc:///tmp/bitcoind.tx.raw
#+END_SRC

Each PUB notification has a topic and body, where the header corresponds to the notification 
type.

These options can be provided in bitcoin.conf as well.

On client side, the 0MQ subscriber socket must have the ZMQ_SUBSCRIBE option set to one or 
either of these prefixes, without doing so will result in no msg arriving.

The 0MQ notification can get lost, and bitcoind appends an up-counting sequence number to 
each notification which allows listeners to detect lost notifications.
* Practice
compile bitcoind as described in bitcoid source code.
#+BEGIN_SRC sh
# bitcoin server start
./src/bitcoind -regtest -daemon

# generate a block chain with 101 blocks
./src/bitcoin-cli -regtest generate 101 

./src/bitcoin-cli -regtest getbalance

./src/bitcoin-cli -regtest newaddress
# mjTa74WdmtSEK2xDFom3QZc8Yw1jXrbrbS
./src/bitcoin-cli -regtest getnewaddress
# mgyyC7t8SZamQuC9H7PwcZwEJ63iw5EQXu
./src/bitcoin-cli -regtest getnewaddress
# n2eS59bLHmMNUWbo7aFsbNQ64JNQ6h3UB9

#+END_SRC
* bitcoin split
- btc(bitcoin)
  segwit and 1MB block size
  cannot mining with GPU.
- BCC(Bitcoin Cash, BCH)
  non segwit and 8MB block size.
  brought by 1st hard fork which activates on Aug.1, 2017.
- BCG
  can mine with GPU.
- segwit2x   
  segwit and 2MB block size 
  cancelled on Nov.9, 2017, and do not happen. 
* BIP141 Segregated Witness
references: [[https://bitcoincore.org/en/segwit_wallet_dev/][Development Guide]]

Witness structure is introduced to check transaction validity.
Witness structure contains scripts and signatures.
Witness structure is committed to blocks separately from the transaction merkle tree.
For soft fork compatible, witness structure is committed in a tree that is nested into the 
block's existing merkle root via the coinbase transaction.
Future hard fork can place this tree in its own branch.

- P2WPKH
  - Data 
    - scriptPubKey
      OP_0 <0x0014 pubkeyHash>
    - scriptSig: (empty)
    - witness: <sig> <pubkey>
  - verification
    HASH160(pubkey)) must equal to <pubkeyHash> in scriptPubkey, then verify signature by 
    <sig> <pubkey> CHECKSIG.
- P2WPKH nested in P2SH
  - Data 
    - scriptPubKey
      HASH160 <0xA914 scriptHash 87> OP_EQUAL
    - scriptSig
      <OP_0 <0x160014 pubkeyHash>>
    - witness
      <sig> <pubkey>
  - verification
    HASH160(pubkey) must equal to pubkeyHash, HASH160(<0X160014 pubkeyHash>) must equal to 
    scriptHash, then verify signature by <sig> <pubkey> CHECKSIG.
- P2WSH
  - Data  
    - scriptPubkey
      OP_0 <0X0020 scriptHash(32bytes)>
    - scriptSig: (empty)
    - witness
      0 <sig1> <sig2> <witnessScript>
      - witnessScript
        <2 <pubkey1> <pubkey2> <pubkey3> 3 CHECKMULTISIG>
  - verification
    SHA256(witnessScript) must equal to scriptHash, then verify signature by 
    OP_0 <sig1> <sig2> 2 <pubkey1> <pubkey2> <pubkey3> 3 CHECKMULTISIG
- P2WSH nested in P2SH
  - Data
    - scriptPubkey
      HASH160 <0xA914 scriptHash(20bytes) 87> EQUAL
    - scriptSig
      <0 <0x220020 scriptHash(32bytes)>>
    - witness 
      OP_0 <sig1> <sig2> <witnessScript>
      - witnessScript
        <2 <pubkey1> <pubkey2> <pubkey3> 3 CHECKMULTISIG>
  - Verification
    SHA256(witnesssScript) must equal to scriptHash(32bytes), and 
    HASH160(0x220020 scriptHash(32bytes)) must equal to scriptHash(20bytes), then veirfy 
    OP_0 <sig1> <sig2> 2 <pubkey1> <pubkey2> <pubkey3> 3 CHECKMULTISIG
     
* private key, public key and address
refer to [[https://www.zhihu.com/question/22399196][一文读懂比特币私钥、公钥、钱包地址的来历和关系]]

