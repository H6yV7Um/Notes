* PoW
- energy consume
- no penalty for reversion
- explicitely lack finality

* PoS
To become a validator, a node need to send a special type of transaction that locks up their
ether intp a deposit. A set of validators take turns proposing and voting on the next block, 
and the weight of each validator's vote depends on the size of its deposit.

Two major types: 
- chain-based PoS
  pseudo-randomly select a validator during each time slot, let it create a single block.
  The new block must point to previous block, and so over time most blocks converge into a 
  single constantly growing chain.
- BFT-style PoS
  validators are randomly assigned the right to propose blocks, but agreeing on which block is 
  canoncial is done through a multi-round process where every validator sends a "vote" for 
  some specific block during each round. 
  The new block may still in be chained together, the key difference is, consensus on a block 
  can come within one block, and does not depends on the length or size of the chain after it.

** advantages
Significant advantages: security, reduced risk of centraliation, energy efficiency.

benefits against PoW:
- No need to consume large quantities of electricity
- Not as much need to issue as many new coins
  Altougth it need coins to motivate participants, be possible to have negative net issuance, 
  where a portion of transaction fee is burned and so the supply goes down over time.
- PoS opens the door to a wider array of techniques that use game-theoretic mechanism design.
- Reduce centralization risks
- make various forms of 51% attacks vastly more expensive.
  In PoS, it can delete the attacker's stake and prevent repeated attacks.
  In PoW, the marginal cost of repeated attack is power cost.
  conclusion, the cost profile of a repeated 51% attack in PoS is as if you ASIC farm burned 
  down because of PoW repeated attacks.


** Long-Range Attacks: The Serious Problem With Adaptive PoW
[[https://blog.ethereum.org/2014/05/15/long-range-attacks-the-serious-problem-with-adaptive-proof-of-work/][blog
]]
In Bitcoin, Long-Range Attacks is hard. In blockchain-based PoW, however, it is a serious 
problem. The reason is that if you start a fork straight from the genesis block, then while 
your mining will be slow at firstm after a few hundred blocks you will be able to fill the 
blockchain up with contracts that are very easy for you to mine, but difficult for everyone 
else. All the attack assumes is, the condition for producing a valid block is dependent on 
the blockchain itself. 

 

** slasher: A Punitive PoS 
PoS, as one prominent Bitcoin developer put it, "there is nothing at stake".

make the chain aware of other chains, if a miner is caught mining on two chains at the same 
time, that miner can be penailzed.

Description here uses address balances, but can easily be used to work with UTXO, or any 
other similar abstraction that currencies use.

Creating block K with PoW but one modification, that is, H(n) included in the block ,and n 
is randomly generated by the miner.

The miner claim the reward by releasing a transaction uncovering n between block K+100 and 
K+900.

At block K+1000, an address with balance B gains a "signing privilege" if 
sha256(n[K]+n[K+1]+...+n[K+99]+A) < 2^256*64*B/M, where M is total money supply.
On average, 64 signing privileges will be assigned each block.

At block K+2000, miners with signing privileges from block K have the opportunity to sign 
the block. The number of signatures is what determines the total length of one blockchain 
versus another. A signature awards the signer a reward that is substantially larger than 
the PoW reward, and this reward will unlock by block K+3000.

Suppose a user detects two signatures made by address A on two distinct blocks with height 
K+2000. That node can publish a transaction containing those two signatures, and if that 
transaction is included before block K+3000, it destroys the reward for that signature and 
sends 33% to the user that ratted the cheater out.

The key to this design is, the signing privilege is based on the block two thousand blocks 
ago.
* Casper
Casper is phase1 deployment of PoS on Ethereum. It adds 
- PoS, layered on top of PoW 
- Finality every 50 blocks [one epoch]
- 51% attack resistance
- reduction in energy waste from PoW

Any ETH holder can become a validator by simply depositing ETH into the Casper smart contract.

The chain is chunked in 50 blocks segments called epochs. Every 50 blocks is considered a 
checkpoint.

Finality is achieved when two consecutive checkpoints receive 2/3 votes. To be finalized, you 
must know that everyone else knows that this block is included in the main chain, steps follow 
- Announce you believe block is in main chain
- Receive same message from 2/3 of validators
- Announce that you heard 2/3 validators announcements
- Receive same message from 2/3 of validators

Each vote counts as 'preparation' of the target epoch, and a 'commitment' on the previous 
epoch.


*** Understanding Serenity, Part2: Casper
[[https://blog.ethereum.org/2015/12/28/understanding-serenity-part-2-casper/][Understanding Serenity Part2; Casper]]

Consensus-by-bet: the protocol offers opportunities for validators to bet against the 
protocol on which blocks are going to be finalized. If the validator win, get reward of 
coins, which are printed out of thin air by protocol; if lose, penalty of coins, which are 
destroyed. In casper universe, things, like account's balance and contract status, are 
derived by looking at which blocks people bet on the most.

If someone has half the coins on PoS chain, and attack the chain, then commonity simply 
needs to coordinate on a patch where clients ignore the attacker's fork, and attacker and 
anyone who plays along with the attacker lose all of their coins. 

In the context of consensus-by-bet, different consensus protocols differ in only one way: 
who is allowed to bet, at what odds and how much?

How to apply Scoring Rule and Revelation Principle on Consensus-by-bet? That is my 
understanding below. Initially, each one can bet on each probability level of each 
block. Scoring Rule can, for each block, elicit a very precision reading of the probability 
the block is likely to be confirmed, then system can give each one minimum information to 
instruct them rebet, and according to Relevation Principle, the minimum info given by 
system, the more likely each one follows the system's advice. 

Casper does consensus by-block other than PoW consensus by-chain, that is, casper consensus 
happens independantly at each height. Strenghts: easy to implement and blocks can be 
produced independantly in theory although block finalization will still take a while. 
Disadvantage: validator's opinions are registered on the block at each every height.
Question: How to handle situation like the 101th block has been finalized but 100th block 
has been not?

How does Casper work?
Casper contract has functions for joining, making bets, withdrawing, and accessing consensus 
information. For each validator, it keeps track of six things:
- return address for validator's deposit
- current size of validator's deposit
- validator's validation code
  The code accepts a hash and a signature, and check it, default check is ECDSA verifier, 
  but one can also experiment with multisig, threshold signature, Lamport signatures, etc.
- sequence number and hash of the most recent bet
  each bet must contain a sequence number one higher than the previous bet, and a hash of 
  the previous bet.
- validator's opinion table
  item in the table contains:
  - what the validator thinks most likely state root is at any given block height
  - what the validator thinks the most likely block hash is at any given block height
  - how likely the block with that hash is to be finalized

Casper process a bet. Firstly, validates the sequence number, previous hash and signature 
of the bet. Next, update the opinion table. Last, apply Scoring Rule to see if a given block 
has a 99% chance of finalization, and you get/lose some stakes.

A validator has two activities: making blocks and making bets.

Block proposition in Casper. A block contains block height, the proposer address, transaction 
root hash and a signature. Firstly, proposer address must be the same as the validator who 
is scheduled to generate a block at given height. Secondly, validator's validation code run 
with arguments transaction root hash and the signature.

Validator Strategy in Casper. The current strategy is designed to mimic aspects of 
traditional BFT consensus: look at how other validators are beting, follow 33% to move 
toward 0 or 1 from there. To accomplish it, each validator need to track current opinion of 
each one. If no or few opinions on a block, then some default probability is used. 
 
