
* 线程
线程是程序执行的最小单位。一个标准的线程由线程ID、当前指令指针PC、寄存器集合及栈组成。

** 线程的访问权限
线程的私有存储空间包括：
- 栈
- 线程局部变量/TLS/
- 寄存器

实际上，线程可以访问进程内所有的数据，包括其他线程的数据。
** 线程安全
*** 函数的可重入（Reentrant）
发生在两种情况
- 多个线程同时执行该函数
- 函数自身调用自身

一个可冲入的函数，必须
- 不使用任何（局部）静态或全局的非const变量
- 不返回任何（局部）静态或全局的非const变量的指针
- 不依赖任何单个资源的锁
- 不调用任何不可重入的函数

*** 过度优化
- 编译器在优化代码时，可能为了效率，
  - 将变量缓存在寄存器而不写回
    #+BEGIN_SRC c
    x = 0;
    //Thread1
    lock();
    x++;
    unlock();
    //Thread2
    lock();
    x++;
    unlock();
    #+END_SRC

    假如Thread1优先执行，但却没把值及时地写回到内存中，而是在Thread2执行完后，则变量的值最终是 1
    
    /volatile/ 关键字可以阻止这种行为（将变量缓存在寄存器而不写回）

  - 交换毫不相干的两条指令的执行顺序。
    #+BEGIN_SRC c
    x = y = 0;
    //Thread1
    x = 1;
    r1 = y;
    //Thread2
    y = 1;
    r2 = x;
    #+END_SRC

    似乎不存在 r1 = r2 = 0 的情况，但若交换了Thread1中两条指令的执行顺乎，就完全可能了。

    /volatile/ 关键字可以阻止编译器的这种行为（交换毫不相干的两条指令的执行顺序）

- CPU 的动态调度
  类同编译器的优化，CPU 也可能交换执行两条指令的执行顺序，但上面提到的 /volatile/ 关键字却无能为力，这时候需要用到 CPU 提供的内存屏障指令。
  #+BEGIN_SRC c
  volatile T* pInst = NULL;
  T* getInstance(){
    if(NULL == pInst){
      lock();
      if(NULL == pInst){
        pInst = new T;
        /* To fix the problem of last expression
        T* tmp = new T;
        barrier(); // CPU 
        pInst = tmp;
        */
      }
      unlock();
    }
  }
  #+END_SRC

  表达式 /pInst = new T;/ 包含三个步骤： 分配内存、调用构造函数、将内存地址赋值给/pInst/，若颠倒了后两个步骤的执行顺序，当将分配好的内存地址赋值给/pInst/，
  但还没来得及执行构造函数时，发生了对该函数的并发调用，则该并发调用会直接返回一个未构造完毕的对象给调用者使用（因为第一个/if/语句为/false/）。

** 线程模型
*** 一对一模型
一个用户使用的线程唯一地对应一个内核中使用的线程，但一个内核里使用的线程不一定有对应的用户态线程存在。

一般直接使用系统调用创建的线程均为一对一的线程。

优点是，线程间是真正的并发，一个线程的阻塞，不会影响其他线程的执行。
缺点是，操作系统限制了内核线程的数量，对应地，用户态的线程数量也受到了限制；由于内核线程切换时开销大，导致用户线程的执行效率低。  
*** 多对一模型
多个用户线程映射到一个内核线程上。

优点是，线程间的切换由用户态的代码完成，切换速度快；对用户线程的数量几乎没限制。
缺点是，一个用户线程的阻塞，使得内核线程也随之阻塞，从而所有的用户线程也阻塞了。
*** 多对多模型
将多个用户线程映射到多个内核线程。


* References
1. [[APUE][http://dirlt.com/apue.html#orgheadline143]]
2. 程序员的自我修养

