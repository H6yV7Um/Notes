#+TITLE: 

* 2.4
不支持内核抢占

时间片和优先级共用一个变量

通过遍历整个runqueue来选择最高优先级的进程运行

runqueue队列中所有进程的时间片都用完时，重新计算所有进程的时间片，那些还未用完的时
间片（比如，睡眠进程的）的时间片会被累计，从而提高了这些进程的优先级。

* 2.6
** 优先级算法
普通进程（交互式进程及批处理进程）的优先级是动态计算的。

实时进程的优先级是不变的，但它总是高于普通进程的优先级。
** pick next 算法
两个优先级队列数组：active, expire

直接从active数组中的最高优先级队列选择第一个进程来执行

每次时钟中断时，更新当前进程的时间片，当进程的时间片为0时，如果是交互式进程或者实时
进程，则重置时间片后，将其重新插入active数组中相应的优先级队列；如果是其他的进程，
则直接移到expire数组中相应的优先级队列。为防止expire中的进程产生饥饿现象，当进程
占用CPU的时间达到一个固定值之后，即使它是实时进程或者交互式进程，也会被移到expire
数组。

* 2.6.23
完全公平调度CFS,不再跟踪进程的平均睡眠时间，不再企图区分交互式进程，将所有进程统一
对待，这就是公平的含义。

CFS抛弃了active/expire数组，使用红黑树选取下一个被调度的进程。所有状态为RUNNABLE的
进程都被插入红黑树。

CFS中，时钟中断发生时，先更新调度信息，然后调整当前进程在红黑树中的位置，之后，若当
前进程不再是最左边的叶子，就设置need_resched标志，在中断返回时就调用scheduler()完成
进程切换，否则，当前进程继续占用CPU。

CFS中红黑树键值的计算，有三个因子：进程已占用的CPU时间、当前进程的nice值、当前的CPU
负载。
- 进程已占用的CPU时间
  该值越大，键值越大，从而当前进程在树中向右移动。
- 当前进程的nice值
  该值越大，键值越大。nice值为1的进程比nice值为0的进程多得10%的CPU时间。
- 当前CPU负载

CFS为每个进程维护两个重要变量：fair_clock, wait_runtime。红黑树的键值为
fair_clock - wait_runtime。fair_clock是一个进程应该获得的CPU时间，等于进程已占用的
CPU时间除以当前runqueue中的进程总数。wait_runtime是进程的等待时间。它们的差值代表了
一个进程的公平程度，值越大，表示进程相对于其它进程越不公平。

CFS还提供了调度器管理器，各种不同的调度算法都可以作为一个模块注册到该管理器。在
2.6.3中，实时进程使用的是实时调度模块。普通进程使用的是CFS算法。

