#+title: APUE(Advanced Programming Unix Environment)
** Unix基础
*** 登录
系统的口令文件存放在/etc/passwd下面，每行是一条记录。每条记录以:分隔包含7个字段
   - username
   - password
   - uid(user id)
   - gid(group id)
   - comment
   - home directory
   - shell

*** 帮助
Linux系统手册分九节，其中，shell命令在第1节(man 1 ls)，系统调用在第2节(man 2 read)，
库函数在第3节(man 3 fread)，而系统管理员手册在第7节。
*** 输入和输出
IO分为不带缓冲IO和带缓冲IO。
不带缓冲IO是指read/write这样的调用需要调用者自己提供buffer来接收内核态读出来的数据。
带缓冲IO是指标准IO,比如printf/getchar/fputs，不需要调用者提供buffer，系统已经提供了。

*** 错误处理
errno在Linux中的实现如下所示，原因是，为了在多线程时，每个线程有一个私有的errno变量。

#+BEGIN_SRC c
extern int *__errno_location(void);
#define errno(*__errno_location());
#+END_SRC 

注意事项
- 在头文件errno.h中定义的任何常量都是非零值
- errno不会被清零
  所以，最好在函数调用前，将其清零，函数返回时，检查返回值，若函数没能正确执行，再
  检查errno。
- 信号处理函数
  信号处理函数中调用的函数（包括可重入函数）可能会修改errno，从而打乱了被信号
  处理函数所中断的系统调用函数对errno的修改。
  正确的方法是，应该在信号处理函数的开始保存errno，在信号处理函数结束时，恢复。

C标准定义了两个函数打印出错信息
#+BEGIN_SRC c
// returns a pointer to string corresponding to the errnum
char *strerror(int errnum);
// print string pointed by msg, followed with ": " and 
// error message corresponding to value of errno
void perror(const char *msg);
#+END_SRC

*** 信号
一个进程向另一个进程发送信号的条件是，发送者进程是超级用户，或者是接受者进程的
所有者。
*** 时间值
#<<进程时间>>

调用 =long sysconf(int name)= 时，传入参数_SC_CLK_TCK可获得每秒的时钟滴答数。

clock_t times(struct tms *buf)将当前进程及其子进程的时间、以时钟滴答为单位记录在
buf中，返回值是开机以来的时钟滴答。

#+BEGIN_SRC c
#include <cstdio>
#include <cstdlib>
#include <cerrno>
#include <unistd.h>
#include <sys/times.h>

int main(){
    long clock_tck_per_sec=sysconf(_SC_CLK_TCK);
    if(clock_tck_per_sec==-1){
        perror("_SC_CLK_TCK not supported");
        exit(-1);
    }
    //operations.
    //...
    struct tms buf;
    if(times(&buf)==-1){
        perror("times failed");
        exit(-1);
    }
    printf("user time:%.3lfs\n"
           "sys time:%.3lfs\n"
           "cuser time:%.3lfs\n"
           "csys time:%.3lfs\n",
           buf.tms_utime*1.0/clock_tck_per_sec,
           buf.tms_stime*1.0/clock_tck_per_sec,
           buf.tms_cutime*1.0/clock_tck_per_sec,
           buf.tms_cstime*1.0/clock_tck_per_sec);
    return 0;
}
#+END_SRC

** Unix标准化以及实现
*** Unix标准化
**** ISO C
ISO C标准定义的头文件包括：

| 头文件       | 说明             |
|--------------+------------------|
| <assert.h>   | 断言             |
| <complex.h>  | 复数             |
| <ctype.h>    | 字符类型         |
| <errno.h>    | 错误码           |
| <fenv.h>     | 浮点环境         |
| <float.h>    | 浮点常量         |
| <inttypes.h> | 整形格式转换     |
| <iso646.h>   | 替代关系操作符宏 |
| <limits.h>   | 限制             |
| <locale>     | 区域             |
| <math.h>     | 数学             |
| <setjmp.h>   | 非局部goto       |
| <signal.h>   | 信号             |
| <stdarg.h>   | 可变参数         |
| <stdbool.h>  | 布尔类型         |
| <stddef.h>   | 标准定义         |
| <stdint.h>   | 整型             |
| <stdio.h>    | 标准IO库         |
| <stdlib.h>   | 通用工具         |
| <string.h>   | 字符串           |
| <tgmath.h>   | 通用类型数学宏   |
| <wchar.h>    | 宽字符           |
| <wctype.h>   | 宽字符类型       |

**** IEEE POSIX
POSIX有一些可选接口组，这个会在Unix系统实现的选项一节介绍。
POSIX标准定义的必选和可选头文件如下：
| 头文件           | 说明             |
|------------------+------------------|
| <dirent.h>       | 目录项           |
| <fcntl.h>        | 文件控制         |
| <fnmatch.h>      | 文件名匹配       |
| <glob.h>         | 路径模块匹配     |
| <grp.h>          | 组文件           |
| <netdb.h>        | 网络数据库       |
| <pwd.h>          | 口令文件         |
| <regext.h>       | 正则表达式       |
| <tar.h>          | tar归档          |
| <termios.h>      | 终端IO           |
| <unistd.h>       | 系统调用         |
| <utime.h>        | 文件时间         |
| <wordexp.h>      | 字扩展           |
| <arpa/inet.h>    | internet定义     |
| <net/if.h>       | 套接字本地接口   |
| <netinet/in.h>   | internet地址族   |
| <netinet/tcp.h>  | tcp协议定义      |
| <sys/mman.h>     | mmap             |
| <sys/select.h>   | select           |
| <sys/socket.h>   | 套接字           |
| <sys/stat.h>     | 文件状态         |
| <sys/times.h>    | 进程时间         |
| <sys/types.h>    | 系统基本数据类型 |
| <sys/un.h>       | unix域套接字     |
| <sys/utsname.>   | 系统名称         |
| <sys/wait.h>     | 进程控制         |
| <cpio.h>         | cpio归档         |
| <dlfcn.h>        | 动态链接库       |
| <fmtmsg.h>       | 消息显示         |
| <ftw.h>          | 文件漫游         |
| <iconv.h>        | 字符转换         |
| <langinfo.h>     | 语言信息         |
| <libgen.h>       | 模式匹配函数     |
| <monetary.h>     | 货币类型         |
| <ndbm.h>         | 数据库           |
| <nl_types.h>     | 消息类别         |
| <pool.h>         | 轮询函数         |
| <search.h>       | 搜索函数         |
| <strings.h>      | 字符串操作       |
| <syslog.h>       | 系统出错日志     |
| <ucontext.h>     | 用户上下文       |
| <ulimit.h>       | 用户限制         |
| <utmpx.h>        | 用户账户数据库   |
| <sys/ipc.h>      | IPC              |
| <sys/msg.h>      | 消息队列         |
| <sys/resource.h> | 资源操作         |
| <sys/sem.h>      | 信号量           |
| <sys/shm.h>      | 共享内存         |
| <sys/statvfs.h>  | 文件系统         |
| <sys/time.h>     | 时间类型         |
| <sys/timeb.h>    | 附加的日期和时间 |
| <sys/uio.h>      | 矢量IO操作       |
| <aio.h>          | 异步IO           |
| <mqueue.h>       | 消息队列         |
| <pthread.h>      | 线程             |
| <sched.h>        | 执行调度         |
| <semaphore.h>    | 信号量           |
| <spawn.h>        | 实时spawn接口    |
| <stropts.h>      | XSI STREAMS接口  |
| <trace.h>        | 事件跟踪         |

**** SUS
Signle Unix Specifcation(单一Unix规范)是POSIX标准的一个超集，定义了一些附加接口，
相应的系统接口全集被称为X/Open系统接口(XSI,X/Open System Interface).XSI还定义了
实现必须支持POSIX的哪些可选部分才能够认为是遵循XSI。只有遵循XSI的实现才能够成为
UNIX系统。_XOPEN_UNIX符号常量表示了XSI扩展的接口。关于XSI提供的附加接口选项，会在
Unix系统实现的选项一节介绍。

*** Unix系统实现
**** 限制
限制主要包括下面三种：
   - 编译时限制(头文件).
   - 不与文件或者是目录相关联的运行时限制(sysconf).
   - 与文件或者是目录相关联的运行时限制(pathconf/fpathconf).

***** 编译时限制
编译时限制可在头文件中定义，程序编译时包含。

编译时限制定义在limits.h文件。
***** sysconf限制
| 参数                 | 说明                                 |
|----------------------+--------------------------------------|
| _SC_ARG_MAX          | exec函数的参数最大长度               |
| _SC_ATEXIT_MAX       | atexit函数注册函数最大个数           |
| _SC_CHILD_MAX        | 每个实际用户id最大的进程数           |
| _SC_CLK_TCK          | 每秒滴答数                           |
| _SC_COLL_WEIGHTS_MAX | 本地文件赋予LC_COLLATE最大权重       |
| _SC_HOST_NAMX_MAX    | gethostname返回主机名最大长度        |
| _SC_IOV_MAX          | 矢量io的最大数                       |
| _SC_LINE_MAX         | 输入行最大长度                       |
| _SC_LOGIN_NAME_MAX   | 登录名最大长度                       |
| _SC_NGROUPS_MAX      | 每个进程同时添加的最大进程组数       |
| _SC_OPEN_MAX         | 每个进程打开文件最大数目             |
| _SC_PAGESIZE         | 系统存储页长度                       |
| _SC_PAGE_SIZE        | 系统存储页长度                       |
| _SC_RE_DUP_MAX       | 正则表达式最大允许重复次数           |
| _SC_STREAM_MAX       | 每个进程的最大标准IO流数             |
| _SC_SYMLOOP_MAX      | 解析路径名期间可遍历的最大符号链接数 |
| _SC_TTY_NAME_MAX     | 终端设备名最大长度                   |
| _SC_TZNAME_MAX       | 时区名的最大字节数                   |

***** pathconf/fpathconf限制
| 参数              | 说明                           |
|-------------------+--------------------------------|
| _PC_FILESSIZEBITS | 目录表示最大文件所需要的位数   |
| _PC_LINK_MAX      | 文件链接数最大值               |
| _PC_MAX_CANON     | 终端规范输入的最大字节数       |
| _PC_MAX_INPUT     | 终端输入的最大字节数           |
| _PC_NAME_MAX      | 文件名的最大字节数             |
| _PC_PATH_MAX      | 路径名的最大字节数             |
| _PC_PIPE_BUF      | 能够原子地写到管道的最大字节数 |
| _PC_SYMLINK_MAX   | 符号链接文件中最大长度         |

**** 选项
选项主要包括下面三种：
   - 编译时选项(头文件).
   - 不与文件或者是目录相关联的运行时选项(sysconf).
   - 与文件或者是目录相关联的运行时选项(pathconf/fpathconf).

***** 编译时选项
如果编译时选项没有指定或为-1，那么必须通过运行时查看选项是否支持。
包含unistd.h这个头文件然后使用宏来判断。对于参数X，使用的宏是_POSIX_<X>, 
通过运行时判断时使用的参数是_SC_<X>.

***** sysconf选项
关于每个可选接口组提供的接口，可以通过posixoptions获得。
| 代码 | 符号                              | 说明                   |
|------+-----------------------------------+------------------------|
| ADV  | _POSIX_ADVISORY_INFO              | 建议性信息             |
| AIO  | _POSIX_ASYNCHRONOUS_IO            | 异步IO                 |
| BAR  | _POSIX_BARRIERRS                  | 屏障                   |
| CPT  | _POSIX_CPUTIME                    | CPU时钟                |
| CS   | _POSIX_CLOCK_SELECTION            | 时钟选择               |
| FSC  | _POSIX_FSYNC                      | 文件同步               |
| IP6  | _POSIX_IPV6                       | ipv6接口               |
| MF   | _POSIX_MAPPED_FILES               | 存储映射文件           |
| ML   | _POSIX_MEMLOCK                    | 进程存储区加锁         |
| MLR  | _POSIX_MEMLOCK_RANGE              | 存储区加锁             |
| MON  | _POSIX_MONOTONIC_CLOCCK           | 单调时钟               |
| MPR  | _POSIX_MEMORY_PROTECTION          | 存储保护               |
| MSG  | _POSIX_MESSAGE_PASSING            | 消息传送               |
| PIO  | _POSIX_PRIORITIZED_IO             | 优先IO                 |
| PS   | _POSIX_PRIORITIZED_SCHEDULING     | 优先进程调度           |
| RS   | _POSIX_RAW_SOCKET                 | 原始套接字             |
| RTS  | _POSIX_REALTIME_SIGNALS           | 实时信号               |
| SEM  | _POSIX_SEMAPHORES                 | 信号量                 |
| SHM  | _POSIX_SHARED_MEMORY_OBJECTS      | 共享存对象             |
| SIO  | _POSIX_SYNCHRONIZED_IO            | 同步IO                 |
| SPI  | _POSIX_SPIN_LOCKS                 | 自选锁                 |
| SPN  | _POSIX_SPAWN                      | 产生进程               |
| SS   | _POSIX_SPORADIC_SERVER            | 进程发散性服务器       |
| TCT  | _POSIX_THREAD_CPUTIME             | 线程CPU时钟            |
| TEF  | _POSIX_TRACE_EVENT_FILTER         | 跟踪事件过滤器         |
| THR  | _POSIX_THREADS                    | 线程                   |
| TMO  | _POSIX_TIMEOUTS                   | 超时                   |
| TMR  | _POSIX_TIMERS                     | 计时器                 |
| TPI  | _POSIX_THREAD_PRIO_INHERIT        | 线程优先级继承         |
| TPP  | _POSIX_THREAD_PRIO_PROTECT        | 线程优先级保护         |
| TPS  | _POSIX_THREAD_PRIORITY_SCHEDULING | 线程执行调度           |
| TRC  | _POSIX_TRACE                      | 跟踪                   |
| TRI  | _POSIX_TRACE_INHERIT              | 跟踪继承               |
| TRL  | _POSIX_TRACE_LOG                  | 跟踪日志               |
| TSA  | _POSIX_THREAD_ATTR_STACKADDR      | 线程栈地址             |
| TSF  | _POSIX_THREAD_SAFE_FUNCTIONS      | 线程安全函数           |
| TSH  | _POSIX_THREAD_PROCESS_SHARED      | 线程进程共享同步       |
| TSP  | _POSIX_THREAD_SPORADIC_SERVER     | 线程发散性服务器       |
| TSS  | _POSIX_THREAD_ATTR_STACKSZIE      | 线程栈大小             |
| TYM  | _POSIX_TYPED_MEMORY_OBJECTS       | 类型化存储对象         |
| XSI  | _XOPEN_UNIX                       | X/Open扩展接口         |
| XSR  | _XOPEN_STREAMS                    | XSI STREAMS            |
|      | _POSIX_JOB_CONTROL                | 作业控制               |
|      | _POSIX_READER_WRITER_LOCKS        | 读写锁                 |
|      | _POSIX_SAVED_IDS                  | 支持saved的uid和gid    |
|      | _POSIX_SHELL                      | POSIX shell            |
|      | _POSIX_VERSION                    | POSIX version          |
|      | _XOPEN_CRYPE                      | 加密                   |
|      | _XOPEN_REALTIME                   | 实时                   |
|      | _XOPEN_REALTIME_THREADS           | 实时线程               |
|      | _XOPEN_STREAMS                    | XSI STREAMS            |
|      | _XOPEN_LEGACY                     | 遗留接口               |
|      | _XOPEN_VERSION                    | XSI版本                |

***** pathconf/fpathconf选项
| 符号                    | 说明                     |
|-------------------------+--------------------------|
| _POSIX_CHOWN_RESTRICTED | chown限制                |
| _POSIX_NO_TRUNC         | 文件名称长于NAME_MAX处理 |
| _POSIX_VDISABLE         | 禁用终端字符             |
| _POSIX_ASYNC_IO         | 是否可以使用异步IO       |
| _POSIX_PRIO_IO          | 是否可以使用优先IO       |
| _POSIX_SYNC_IO          | 是否可以使用同步IO       |

**** 功能测试宏
如果使用编译时限制或者是选项的话，有时候各个厂商会有自己的定义。如果想撇开这些
厂商自己的定义的话而使用标准POSIX或者是XSI定义的话，那么可以使用宏：
   - -D_POSIX_C_SOURCE //开启POSIX
   - -D_XOPEN_SOURCE //开启XSI
如果需要支持ISO C的话，那么使用__STDC__来判断。如果需要支持C++的话，那么使用
__cplusplus来判断。

**** 基本系统数据类型
在头文件<sys/types.h>里面定义了某些与实现相关的数据类型，称为基本系统数据类型。常见的有下面这些：
| 类型         | 说明             |
|--------------+------------------|
| caddr_t      | 内存地址         |
| clock_t      | 时钟滴答计数器   |
| comp_t       | 压缩的时钟滴答   |
| dev_t        | 设备号           |
| fd_set       | 文件描述符集合   |
| fpos_t       | 文件位置         |
| gid_t        | 组id             |
| ino_t        | i节点编号        |
| mode_t       | 文件类型         |
| nlink_t      | 链接计数         |
| off_t        | 文件偏移         |
| pid_t        | 进程id和进程组id |
| ptrdiff_t    | 指针偏移         |
| rlim_t       | 资源限制         |
| sig_atomic_t | 原子访问数据类型 |
| sigset_t     | 信号集           |
| size_t       | 对象大小         |
| ssize_t      | 字节计数         |
| time_t       | 日历时间         |
| uid_t        | 用户id           |
| wchar_t      | 宽字符           |

** 文件IO
进程打开的文件描述符的上限，可以通过sysconf得到。

*** open/openat/create
open打开文件返回文件描述符。允许指定读写方式，是否创建(O_CREAT)，创建已经存在的文件
是否会出错(O_EXCL,exclusive)，是否追加，是否truncate,是否阻塞，权限等标记，同时还
允许指定是否每次write需要等待物理IO操作完成。对于open每次一定都是返回最小的未使用的
文件描述符。而create可以理解为open的包装:).注意这里O_CREAT也非常关键，语义是入如果
不存在就创建，这样使得这个操作成为一个原子操作。

还有下面常用方式：
- O_RDONLY.只读
- O_WRONLY.只写
- O_RDWR.读写
- O_APPEND.追加
- O_EXCL. 同时指定O_CREATE，可用于原子性地测试文件是否存在并创建文件。
- O_DIRECTORY. 若path不是目录，则出错。
- O_EXEC. 仅为执行而打开。
- O_SEARCH. 仅为收索而打开，应用于目录。
- O_CLOEXEC. 
- O_NOFOLLOW. 若path是符号链接，则报错。
- O_NONBLOCK. 若path是FIFO、块特殊文件、或字符特殊文件，则设置本次打开操作及后续IO为
  非阻塞。
- O_SYNC. 每次write返回时，都要确保物理IO操作完成，且文件属性得到更新。
- O_DSYNC. 每次write返回时，都要确保物理IO操作完成，如果文件属性不影响对刚写入的数据
  的读取，可以不等着更新文件属性的操作完成。
- O_RSYNC. 每次read前，都会等待挂起的对文件同一部分的写操作的完成。
- O_ASYNC.信号驱动IO。
- O_DIRECT.direct io.注意direct io只是在64位下面才有效。
  要求读写的起始地址，读写大小，以及用户buffer地址都必须是PAGE_SIZE的整数倍。
  虽然在32位机器上可以打开_GNU_SOURCE这个宏来使用O_DIRECT编译但是却不能够运行。

*** close
close允许关闭文件描述符。关闭一个文件会释放该进程在文件上所有记录锁。程序退出的时候
自动关闭所有打开的文件描述符，利用这点很多程序在退出时候并不显示关闭文件描述符。

*** lseek
lseek允许显示设置文件当前偏移量。如果文件描述符是一个管道，FIFO或者是网络套接字,那么
返回ESPIPE的错误。测试lseek的返回值时，应测试其是否为-1，而非其是否小于0，因为对于某
些设备lseek可能返回负数。lseek仅仅是修改进程对于这个文件访问时的逻辑偏移，实际上不
进行任何物理IO操作。使用lseek允许造成文件空洞(通常见于core文件),空洞部分并不占用
磁盘存储空间。

#+BEGIN_SRC c
#include <fcntl.h>
#include <unistd.h>
#include <cstring>
int main(){
    int fd=open("hole",O_WRONLY | O_CREAT,0666);
    write(fd,"1G hole are coming",strlen("1G hole are coming"));
    lseek(fd,1024*1024*1024,SEEK_CUR);
    write(fd,"1G hole are ending",strlen("1G hole are ending"));
    close(fd);
    return 0;
}
#+END_SRC
创建1G的空洞，可以查看
#+BEGIN_EXAMPLE 
[dirlt@localhost.localdomain]$ ll hole
-rw-r--r-- 1 dirlt dirlt 1073741860 05-17 08:11 hole

[dirlt@localhost.localdomain]$ du -h hole
20K     hole
#+END_EXAMPLE
关于占用多少真实磁盘大小是文件系统所关心的，Linux下面使用20K来保存空洞文件。

*** read
read从文件当前偏移开始读出数据，并且修改当前文件偏移。read允许指定需要读取数据多少，
但是并不一定会返回这么多的数据，返回值就是已经读取的字节数。基本上对于终端，网络，
管道，FIFO等文件，都需要多次读取才能够完成，比较例外的就是磁盘了。同时我们必须注意
信号中断的情况，这时read会指出EINTR的错误，通常来说我们还需要继续读。

*** readahead
readahead可以异步地发起IO操作将所需要读入磁盘内容读入page cache,这样后续发起的read
则不会从磁盘上读取而是直接从page cache读取。

*** write
write也是从当前偏移开始写数据的（如果打开文件时设置了O_APPEND选项，则会从
文件最末尾开始写数据），写完后更新文件偏移量。被信号中断时，write会指出EINTR错误。

O_APPEND选项非常重要，可以让多个线程对于同一文件的追加操作成为原子操作。如果
write大小不超过PIPE_BUF的话保证是原子操作。

除非使用O_DIRECT否则write通常是先写page cache，然后系统将page cache刷到磁盘上面去。
系统将page cache写回到磁盘上的时机包括下面几个：
- 定时回写
- 脏页超过一定比例
- 空闲内存不足
- 用户调用sync
另外write可能会修改inode节点(这些inode节点也是保存在cached memory里面的).这些inode
节点写回磁盘的时机和page cache写回磁盘时机是一样的。

对于这些脏页的写回策略是：
- 首先判断脏页比例是否超过dirty_ratio.如果没有的话那么直接退出
- 然后开始将脏页刷到磁盘直到比率小于dirty_ratio.（此时write会阻塞）
- 判断脏页比例是否超过dirty_background_ratio或者是超过dirty_background_bytes.如果
  没有那么退出。
- 如果超过的话那么就会启动pdflush daemon后台进程刷新脏页。（此时write不会阻塞）

注意到这里可能启动pdflush daemon在后台刷新脏页。另外系统每隔dirty_writeback_centisecs
时间会启动pdflush daemon将脏页刷到磁盘上面。而pdflush daemon工作方式是这样的，检查脏
页是否存在超过dirty_expire_centisecs时间的，如果超过的话那么就会在后台刷新这些脏页。

如果写入量巨大，不能期待系统缓存的自动回刷机制，最好采用应用层调用fsync或者sync。如
果写入量大，甚至超过了系统缓存自动刷回的速度，就有可能导致系统的脏页率超过
/proc/sys/vm/dirty_ratio， 这个时候，系统就会阻塞后续的写操作，这个阻塞有可能有5分钟
之久，是我们应用无法承受的。因此，一种建议的方式是在应用层，在合适的时机调用fsync。

-----

 http://blog.chinaunix.net/uid-27105712-id-3270102.html

下面是整个write过程
file:./images/linux-write-procedure.gif
- glibc write是将app_buffer->libc_buffer->page_cache
- write是将app_buffer->page_cache
- mmap可以直接获取page_cache直写
- write+O_DIRECT的话将app_buffer写到io_queue里面
- io_queue一方面将写邻近扇区的内容进行merge，另外一方面进行排序确保磁头和磁盘
  旋转最少。
- io_queue的工作也需要结合IO调度算法。不过这些仅仅对于physical disk有效。
- 对于ssd而言的话，因为完全是随机写，基本没有调度算法。
- driver（filesystem module）通过DMA写入disk_cache之后(使用fsync就可以强制刷新)到
  disk上面了。
- 直接操作设备（RAW）方式直接写disk_cache.

O_DIRECT 和 RAW设备最根本的区别是O_DIRECT是基于文件系统的，也就是在应用层来看，其操
作对象是文件句柄，内核和文件层来看，其操作是基于inode和数据块，这些概念都是和ext2/3
的文件系统相关，写到磁盘上最终是ext3文件。而RAW设备写是没有文件系统概念，操作的是扇
区号，操作对象是扇区，写出来的东西不一定是ext3文件（如果按照ext3规则写就是ext3文件）。
一般基于O_DIRECT来设计优化自己的文件模块，是不满系统的cache和调度策略，自己在应用层
实现这些，来制定自己特有的业务特色文件读写。但是写出来的东西是ext3文件，该磁盘卸下来，
mount到其他任何linux系统上，都可以查看。而基于RAW设备的设计系统，一般是不满现有ext3
的诸多缺陷，设计自己的文件系统。自己设计文件布局和索引方式。举个极端例子：把整个磁盘
做一个文件来写，不要索引。这样没有inode限制，没有文件大小限制，磁盘有多大，文件就能多
大。这样的磁盘卸下来，mount到其他linux系统上，是无法识别其数据的。两者都要通过驱动层
读写；在系统引导启动，还处于实模式的时候，可以通过bios接口读写raw设备。

*** pread/pwrite
pread/pwrite相当于原子性地完成了lseek+read/write操作，并且不修改当前文件偏移。

在Linux中，如果打开文件时指定了O_APPEND，则pwrite总是写数据到文件尾，而去传入的参数
offset无关。

多线程应用中，尽管进程下辖的多个线程共享同一个文件描述符表，也即每个已打开的文件的
文件偏移量为多个线程共享，但是某个线程pread/pwrite时，不会因文件偏移量影响到其他线
程。

#+BEGIN_SRC c
#include <fcntl.h>
#include <unistd.h>
#include <cstring>
#include <cstdio>
int main(){
    int fd=open("main.cc",O_RDONLY);
    char buf[128];
    memset(buf,0,sizeof(buf));
    for(int i=0;i<10;i++){
        //每次读取到的都是相同的内容
        pread(fd,buf,sizeof(buf)-1,128);
        printf("%s\n",buf);
    }
    close(fd);
    return 0;
}
#+END_SRC

*** dup/dup2
#+BEGIN_SRC c
int dup(int fd);
int dup2(int src_fd,int dst_fd);
#+END_SRC
dup2允许指定将src_fd复制给某个dst_fd,而dup是将fd复制给最小未使用的fd.
dup2相当于一个原子操作，首先关闭dst_fd然后再复制到dst_fd上面。

*** sync/fsync/fdatasync
操作系统为了提高文件读写效率，在内核层提供了读写缓冲区。对于磁盘的写并不是立刻写入磁
盘，而是首先写入页面缓冲区然后定时刷到硬盘上。但是这种机制降低了文件更新速度，并且如
果系统发生故障，那么会造成部分数据丢失。这里的3个sync函数就是为了这个问题的。
- sync.将所有修改过的块缓冲排入写队列后返回，并不等实际磁盘操作完成。
- fsync.将某个fd涉及到的页面缓存同步更新到磁盘上(包括文件属性等信息).
- fdatasync.将某个fd涉及到的数据页面缓存同步更新到磁盘上。

*** fcntl
全称是file control,可以改变已经打开文件的性质，共有下面5种功能：
- F_DUPFD.将现有文件描述符复制到尚未打开且大于2的最小描述符，并返回该新描述符。
  新、老两个描述符共享一个文件对象，故有相同的文件状态标志，但新描述符有自己的文件
  描述符标志FD_CLOEXEC，且该标志已清零。
- F_GETFD/F_SETFD.获得/设置现有文件描述符标记(现只有FD_CLOEXEC).
- F_SETFL/F_GETFL.获得/设置现有文件状态标记。
- F_GETOWN/F_SETOWN.获得/设置当前接受SIGIO和SIGURG信号的进程ID或进程组ID(设置异步
  IO所有权).
- F_GETLK/F_SETLK/F_SETLKW.获得/设置记录锁。

*** ioctl

#+BEGIN_SRC C++
#include <unistd.h>
#include <sys/ioctl.h>
#include <stropts.h>
#+END_SRC

但是这仅仅是ioctl所需要包含的文件，不同设备还有专有的头文件：
| 类别     | 常量    | 头文件            |
|----------+---------+-------------------|
| 盘标号   | DIOxxx  | <sys/disklabel.h> |
| 文件IO   | FIOxxx  | <sys/filio.h>     |
| 磁带IO   | MTIOxxx | <sys/mtio.h>      |
| 套接字IO | SIOxxx  | <sys/sockio.h>    |
| 终端IO   | TIO     | <sys/ttycom.h>    |

*** /dev/fd/n
| 文件        | 对象     |
|-------------+----------|
| /dev/fd/0   | 标准输入 |
| /dev/stdin  |          |
| /dev/fd/1   | 标准输出 |
| /dev/stdout |          |
| /dev/fd/2   | 标准错误 |
| /dev/stderr |          |

使用open打开任何一个/dev/fd/n文件，相当于进行了文件描述符复制。并且需要注意
的是，比如对于标准输入只允许读的话，那么如果open使用RDWR打开的话那么写依然是没有作用
的。在shell下面如果程序需要传入一个文件名从文件里面读入内容的话，我们提供/dev/fd/0
的话，那么程序就可以从标准输入中读取内容，这点非常方便。

** 文件和目录
这章主要说明文件系统的其他特征和文件的性质(文件属性)。

获取一个文件属性可以使用下面这几个函数来获得：
- stat(const char* restrict pathname,struct stat* restrict buf);
- fstat(int fd,struct stat* restrict buf);
- lstat(const char* restrict pathname,struct stat* restrict buf)
  当pathname是符号链接时，返回符号链接的信息，而非链接引用的文件的信息。

#+BEGIN_SRC c
struct stat{
    mode_t st_mode; //文件类型和访问权限
    ino_t st_ino; //inode编号
    dev_t st_dev; //设备号(对于文件系统来说)
    dev_t st_rdev; //设备号(对于特殊文件来说)
    nlink_t st_nlink; //链接数目
    uid_t st_uid; //文件所有者uid
    gid_t st_gid; //文件所有者gid
    off_t st_size; //文件大小
    time_t st_atime; //access time
    time_t st_mtime; //modification time
    time_t st_ctime; //属性最近一次change time
    blksize_t st_blksize; //block size
    blkcnt_t st_blocks; //blocks
};
#+END_SRC

检查文件类型的宏
| 宏                     | 文件类型 |
|------------------------+----------|
| S_ISREG(stat.st_mode)  | 普通文件 |
| S_ISDIR(stat.st_mode)  | 目录     |
| S_ISCHR(stat.st_mode)  | 字符设备 |
| S_ISBLK(stat.st_mode)  | 块设备   |
| S_ISFIFO(stat.st_mode) | 管道     |
| S_ISLNK(stat.st_mode)  | 符号链接 |
| S_ISSOCK(stat.st_mode) | 套接字   |

在Linux上面为了使用S_ISSOCK需要使用_GNU_SOURCE这个选项。

Posix定义的IPC类型宏
| 宏                | IPC类型  |
|-------------------+----------|
| S_TYPEISMQ(stat)  | 消息队列 |
| S_TYPEISSEM(stat) | 信号量   |
| S_TYPEISSHM(stat) | 共享内存 |


*** 文件系统
首先我们可以将一块磁盘进行分区，这样每个区就可以在上面建立一个文件系统。
一个文件系统可以表示为下面这样的数据结构：
#+BEGIN_SRC c
//Physical File System
struct PFS{
    //这个部分内容可以直接载入内存来进行管理
    Block boot; //自举块
    Block super; //超级块
    Configuration config; //配置信息
    Bitmap inode_bitmap; //inode节点的bitmap
    Bitmap dblock_bitmap; //数据块的bitmap
    //下面这些内容不能够载入内存
    Inode inodes[]; //inode节点数组
    DataBlock dblocks[]; //数据块数组
};
#+END_SRC
可以看到为了管理一个文件系统，在内存中主要存放inode和数据块的bitmap,表示哪些inode和
数据块是空闲的。

然后对于Inode节点来说，里面存放的就是数据块的索引。这里为了概念上表示方便而使用数组
表示的，实际上Inode可能有简介索引，指向的并不一定就是直接可以的读取数据块，可能数据
块上面存放的是更多数据块的指针。

#+BEGIN_SRC c
struct Inode{
    FileAttribute attr; //文件属性
    index_t datablock[]; //数据块的索引
};
#+END_SRC

但是可以确信一点的就是，一个文件在同一个文件系统中对应一个inode.文件属性对应的就是
struct stat这个结构。可以看到文件属性是存放在inode节点上而不是数据块上的。

对于一个目录项来说，结构大致如下：
#+BEGIN_SRC c
//目录项
struct DirectoryEntry{
    char filename[]; //文件名
    index_t inode; //对应的inode索引
};

struct Directory{
    DirectoryEntry entries[]; //目录项数组
};
#+END_SRC

目录里面存放的就是文件名和对应的inode索引。

对于符号链接来说，在文件属性标记是否为符号链接，然后磁盘内容就是目的地文件系统路径。

#+BEGIN_EXAMPLE
[dirlt@localhost.localdomain]$ touch a
[dirlt@localhost.localdomain]$ ln -s ./a b
[dirlt@localhost.localdomain]$ ln -s /home/dirlt/cvs/opencode/zyspace/doc/a b2
[dirlt@localhost.localdomain]$ ll b b2
lrwxrwxrwx 1 dirlt dirlt  3 05-19 08:14 b -> ./a
lrwxrwxrwx 1 dirlt dirlt 38 05-19 08:15 b2 -> /home/dirlt/cvs/opencode/zyspace/doc/a
[dirlt@localhost.localdomain]$
#+END_EXAMPLE
可以看到b长度为3,正好等于"./a"长度，而b2长度为38也等于"/home/dirlt/cvs/opencode/zyspace/doc/a"长度。

*** 设置用户ID和设置组ID
对于一个进程来说，相关联的ID有下面几个：
- 实际用户ID、实际组ID：我们是谁
  会话期间不改变。超级用户可修改。
- 有效用户ID、有效组ID：以什么权限运行
  通常等于实际用户ID、实际用户组ID。
- 保存的设置用户ID、保存的设置组ID
  执行一个程序时，用于保存有效用户ID、有效用户组ID。
  这是可选的。可以在编译时测试_POSIX_SAVED_IDS，或运行时调用sysconf(_SC_SAVED_IDS)
  测试.

如果一个文件的st_mode中set-user-id(set-group-id)位被设置，则当这个文件被执行时，执
行它的进程的有效用户ID（有效组ID）会被暂时设置为文件的所有者ID(st_uid)
（所有者组ID(st_gid)）。注意，
- 这个文件是否可执行与set-user-id(set-group-id)无关。
- 该文件的其他用户执行该文件时，其euid（egid）也被设置为文件的所有者ID（文件组ID）

*** 文件访问权限
文件访问权限也可以通过访问st_mode来获得，有下面9个权限位：
| 权限    | 意义        |
|---------+-------------|
| S_IRUSR | user read   |
| S_IWUSR | user write  |
| S_IXUSR | user exec   |
| S_IRGRP | group read  |
| S_IWGRP | group write |
| S_IXGRP | group exec  |
| S_IROTH | other read  |
| S_IWOTH | other write |
| S_IXOTH | other exec  |

目录是一个特殊文件，可以将目录想象成为里面都是文件的名称然后配上必要的索引信息。
目录的读权限，就是可以获得里面所有的文件名内容。目录的执行权限，就是通过该目录
搜索、访问某个文件或下一级目录。

文件访问权限的规则：对所经过路径中的所有目录都有执行权限。如果是创建或删除文件，
还要求对最后一级目录有写权限。被创建的文件的所有者ID和组ID分别设置为进程的有效
用户ID和有效组ID。删除进程的有效用户ID（或有效组ID）需与被删除文件的所有者ID（
或文件的组ID）匹配，或者是超级用户。读、写、执行文件时，要求进程必须是，超级用户，
或者进程的有效用户ID（或有效组ID）等于文件的所有者ID（或文件的组ID）并且文件相应的
读、写、执行权限位置位，或者文件对其他用户开放了相应的读、写、执行权限。

其实创建文件时，新文件的组ID还有另外一种可能，那就是继承上级目录的组ID.
Linux系统是这样的：如果上级目录设置了设置gid位的话，那么就继承上级的组ID,否则就使
用创建者进程的有效组ID.

**** access/faccessat
access/faccessat函数是按照进程实际uid和gid来检测访问权限的。

#+BEGIN_SRC c
int access(const char *pathname, int mode);
int faccessat(int fd, const char *pathname, int mode, int flag);
#+END_SRC

mode取值，F_OK测试文件存在，R_OK测试读权限，W_OK测试写权限，X_OK测试执行权限。

pathname为绝对路径时，fd被忽略。pathname为相对路径时，则表明是相对于fd，特别是
当fd取值为AT_FDCWD时，表示的是相对于当前路径。

flag取值为AT_EACCESS时，faccessat是按进程的有效uid和有效组ID检测权限的。

#+BEGIN_SRC c
#include <unistd.h>
#include <fcntl.h>

int main(int argc, char *argv[]) {
  if(argc != 2) {
    printf("Wrong number of arguments\n");
    exit(1);
  }

  printf("uid=%d, euid=%d\n", getuid(), geteuid());

  if(access(argv[1], R_OK) <0)
    printf("access error for %s\n", argv[1]);
  else
    printf("access ok\n");
 
  if(faccessat(AT_FDCWD, argv[1], R_OK, AT_EACCESS) <0)
    printf("faccessat error for %s\n", argv[1]);
  else
    printf("faccessat ok\n");

  if(open(argv[1], O_RDONLY) <0)
    printf("open error for %s\n", argv[1]);
  else
    printf("open for read ok\n");

  return 0;
}
#+END_SRC

#+BEGIN_EXAMPLE
~/APUE $ whoami
ubuntu
~/APUE $ ls -l /etc/shadow-
-rw-------   1 root           root          906 2017-03-09 03:40 /etc/shadow-
~/APUE $ gcc myaccess.c -o rootaccess
~/APUE $ su
Password:
root@ip-172-31-26-73:/home/ubuntu/APUE# chown root rootaccess
root@ip-172-31-26-73:/home/ubuntu/APUE# chmod u+s rootaccess //置位set-user-id
root@ip-172-31-26-73:/home/ubuntu/APUE# exit
exit
~/APUE $ ls -l rootaccess
-rwsrwxr-x   1 root           ubuntu       8968 2017-05-21 14:28 rootaccess
~/APUE $ ./rootaccess /etc/shadow-
uid=1000, euid=0
access error for /etc/shadow-
faccessat ok
open for read ok
#+END_EXAMPLE

可以注意到，作为实际用户为ubuntu的普通进程，在执行文件rootaccess时，其有效用户ID成
为了0(root)，所以，它能文件/etc/shadow-，但其实际用户ID还是1000(ubuntu)，是没有
权限读文件/etc/shadow-的。

**** umask
umask为进程设置创建文件（目录）时的模式(mode)屏蔽字，屏蔽字mask是文件所有者、
文件组、文件的其它用户的读、写、执行权限位的任意组合，并返回旧的模式屏蔽字。这样，
当使用open和mkdir创建文件和目录时，会自动从传入的文件模式mode中屏蔽掉进程模式屏蔽
字中指定的用户的指定权限。

**** chmod/fchmod/fchmodat
修改现有文件的访问权限。除了上面列列举权限位可以使用之外，还有下面这些：

| 权限位  | 说明             |
|---------+------------------|
| S_ISUID | 开启设置uid      |
| S_ISGID | 开启设置gid      |
| S_ISVTX | 保存正文(粘住位) |
| S_IRWXU | user rwx         |
| S_IRWXG | group rwx        |
| S_IRWXO | other rwx        |

修改权限位，要求进程的有效用户ID必须等于文件的所有者ID，或为超级进程。

对于在分页机制出来之前的Unix操作系统，设置粘住位可以使得程序的正文段始终驻留在内存
中来加快程序运行速度，很明显结果就是粘住位文件数量有一定限制，但是采用分页机制之后
这个不需要了。而现在粘住位主要是针对目录来设置的。对于目录设置了粘住位之后，那么具
有下面权限之一才允许删除或者是更名目录下面的文件：
- 拥有此文件
- 拥有此目录
- 超级用户

对于/tmp目录非常适合。每个用户都可以写入文件，虽然用户对目录有执行和写权限，但是却
不允许删除或者是更名/tmp目录下面的文件。

**** chown/fchown/fchownat/lchown
修改文件的uid和gid.如果值为-1的话表明对应id不变。

lchown用于修改符号链接本身的所有者，而非符号链接所指向的文件的所有者。
调用fchownat，且参入的flag参数是AT_SYMLINK_NOFOLLOW时，该函数表现同lchown。


若开启了_POSIX_CHOWN_RESTRICTED（可调用pathconf(_POSIX_CHOWN_RESTRICTED)查询），则
- 超级用户才允许更改uid.
- 非超级用户可以修改文件的组ID，前提是
  - 该用户是文件的所有者，即该用户进程的有效用户ID等于文件的所有者ID。
  - 参数owner的调用值是-1或文件的所有者ID。
  - 参数group的应是该用户所归属的组，比如有效组ID或补充组ID。

如果函数由非超级用户调用，则文件的设置uid(set-user-id)和设置gid(set-group-id)
都会被清除。

*** 文件长度
文件长度对应st_size字段，而文件使用的块大小对应st_blksize字段，占用块数对应
st_blocks字段。
通常，st_size和st_blksize*st_blocks应该是很接近的，除非一种情况就是文件空洞。
对于有空洞的文件，st_size可能很大，而实际占用磁盘空间却很少。

#+BEGIN_SRC c
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>
#include <cstring>
#include <cstdio>
int main(){
    //产生一个空洞文件
    int fd=open("hole",O_WRONLY | O_CREAT,0666);
    write(fd,"1G hole are coming",strlen("1G hole are coming"));
    lseek(fd,1024*1024*1024,SEEK_CUR);
    write(fd,"1G hole are ending",strlen("1G hole are ending"));
    close(fd);
    struct stat buf;
    stat("hole",&buf);
    printf("size:%lu,st_blksize:%lu,st_blocks:%lu\n",
           buf.st_size,buf.st_blksize,buf.st_blocks);
    return 0;
}
#+END_SRC
#+BEGIN_EXAMPLE
[dirlt@localhost.localdomain]$ ./main
size:1073741860,st_blksize:4096,st_blocks:40
#+END_EXAMPLE

*** 文件截断
#+BEGIN_SRC C++
int truncate(const char* filename,off_t length);
int ftruncate(int fd,off_t length);
#+END_SRC

如果length比原来文件短的话，那么文件在length偏移之后数据就不可以访问了。如果length
比原来文件长的话，那么会创造一个空洞。

*** 文件链接
关于文件链接分为硬链接和软链接，软链接也称为符号链接。

**** 硬链接
创建一个硬链接效果就是，选择一个文件名然后选择一个已经使用的inode编号存放在目录
下面。一旦创建硬链接之后，那么被链接的文件的属性里面就会将链接数目+1.链接数目对
应于struct stat结构里面的st_nlink字段。

可以看到硬链接是使用inode节点来操作的，所以硬链接是不可以跨越文件系统的。另外需
要注意的是，大多数操作系统仅限于超级用户进行目录的硬链接，因为这样做可能会造成
文件系统中形成循环，而大多数程序无法处理这种情况而且很容易搞乱文件系统。

#+BEGIN_SRC c
int link(const char* existingpath,const char* newpath);
int linkat(int efd, const char *existingpath, int nfd, const char *newpath, int flag);
#+END_SRC

若newpath已经存在，则出错。函数只创建newpath路径中的最后一个分量，其他分量应已存在。
efd和nfd的取值可以是AT_FDCWD，表示当前工作目录。existingpath是绝对路径时，efd将被忽略。
newpath是绝对路径时，nfd将被忽略。flag中未设置AT_SYMLINK_FOLLOW时，创建的链接指向符
号链接本身，否则，指向符号链接的链接目标。

创建目录项与增加链接计数是一个原子操作。

**** 符号链接
相比于硬链接，符号链接可以跨越文件系统，可以由普通进程创建。

| 函数     | 不跟随链接 | 跟随链接 |
|----------+------------+----------|
| access   |            | Y        |
| chdir    |            | Y        |
| chmod    |            | Y        |
| chown    |            | Y        |
| creat    |            | Y        |
| exec     |            | Y        |
| lchown   | Y          |          |
| link     |            | Y        |
| lstat    | Y          |          |
| open     |            | Y        |
| opendir  |            | Y        |
| pathconf |            | Y        |
| readlink | Y          |          |
| remove   | Y          |          |
| rename   | Y          |          |
| stat     |            | Y        |
| truncate |            | Y        |
| unlink   | Y          |          |

创建符号链接函数为symlink/symlinkat，链接的目标文件可以不存在，
也可以位于另一个文件系统。

读取符号链接本身的函数为readlink/readlinkat。

*** 文件删除与重命名
#+BEGIN_SRC c
int unlink(const char *pathname);
int unlinkat(int fd, const char *pathname, int flag);
#+END_SRC

递减链接st_nlink数目，如果递减为0，且文件没有被进程打开，则删除文件。

#+BEGIN_SRC C++
#include <cstdio>
#include <fcntl.h>
#include <unistd.h>
int main(){
    int fd=open("hello",O_RDWR | O_TRUNC | O_CREAT,0666);
    unlink("hello");
    write(fd,"hello",6);
    lseek(fd,0,SEEK_SET);
    char buf[12];
    buf[0]=0;
    read(fd,buf,sizeof(buf));
    //尽管之前unlink了
    //依然可以读取到hello
    printf("%s\n",buf);
    close(fd);
}
#+END_SRC

文件删除也可以是用remove函数，目录删除应用rmdir函数。

*** 文件时间
文件时间分为：
- 文件数据的最后访问时间st_atime，比如read
- 文件数据的最后修改时间st_mtime，比如write
- inode节点状态的最后更改时间st_ctime，比如chmod和chown

注意，没有inode节点状态的最后访问时间，所以，像access和stat这样的函数调用并不影响
文件3个时间中的任一个。

| 函数               | 文件access | 文件modify | 文件change | 父access | 父modify     | 父change     |
|--------------------+------------+------------+------------+----------+--------------+--------------|
| chmod/fchmod       |            |            | Y          |          |              |              |
| chown/fchown       |            |            | Y          |          |              |              |
| creat(O_CREAT)     | Y          | Y          | Y          |          | Y            | Y            |
| creat(O_TRUNC)     |            | Y          | Y          |          |              |              |
| exec               | Y          |            |            |          |              |              |
| lchown             |            |            | Y          |          |              |              |
| link               |            |            | Y          |          | Y(2nd param) | Y(2nd param) |
| mkdir              | Y          | Y          | Y          |          | Y            | Y            |
| mkfifo             | Y          | Y          | Y          |          | Y            | Y            |
| open(O_CREAT)      | Y          | Y          | Y          |          | Y            | Y            |
| open(O_TRUNC)      |            | Y          | Y          |          |              |              |
| read               | Y          |            |            |          |              |              |
| remove(unlink)     |            |            | Y          |          | Y            | Y            |
| remove(rmdir)      |            |            |            |          | Y            | Y            |
| rename             |            |            | Y          |          | Y            | Y            |
| rmdir              |            |            |            |          | Y            | Y            |
| truncate/ftruncate |            | Y          | Y          |          |              |              |
| unlink             |            |            | Y          |          | Y            | Y            |
| utime              | Y          | Y          | Y          |          |              |              |
| write              |            | Y          | Y          |          |              |              |

通过下面的函数可以修改文件数据的最后访问时间st_atime及文件数据的最后修改时间st_mtime

#+BEGIN_SRC c
int futimens(int fd, const struct timespec times[2]);
int utimensat(int fd, const char *path, const struct timespec times[2], int flag);
#+END_SRC
参数times的具体含义，以及使用该函数所需的权限，请查询手册。

不能直接修改inode阶段的最后更改时间st_ctime。

*** 目录操作
创建目录函数是mkdir和mkdirat. mkdir常犯错误是权限为0666和文件相同，通常，目录是
需要可执行权限的，否则没法访问其中的文件，目录也是需要写权限的，否则没法在其中
创建或删除文件。

删除目录的函数是rmdir. rmdir要求目录必须是空目录。和删除文件一样，如果链接数为0并
且没有进程打开之后才会释放空间。如果链接数==0时候，有其他进程打开目录的话，那么会
删除.和..,然后也不允许添加新的目录项，等到打开目录进程退出之后，才会释放磁盘空间。

读取目录函数是：
- DIR *opendir(const char *pathname)
- struct dirent *readdir(DIR *dp)
  每调用一次返回一个目录项，返回NULL时，表示结束或出错，返回的顺序和目录实现相关。
- void rewinddir(DIR *dp)
  重置目录流的读取位置
- int closedir(DIR *dp)
- long telldir(DIR *dp)
  获取目录流的读取位置
- void seekdir(DIR *dp, long loc)
  设置目录流的读取位置

chdir,fchdir可以帮助切换调用进程的当前工作目录，而getcwd可以获得当前工作目录。

*** 特殊设备文件
st_dev是设备号，分为主次设备号：

#+BEGIN_SRC c
major(stat.st_dev) //主设备号
minor(stat.st_dev) //次设备号
#+END_SRC

主设备号表示设备驱动程序，而次设备号表示特定的子设备。

st_rdev只有字符特殊文件和块特殊文件才有这个值，表示实际设备的设备编号。

#todo: st_dev与st_rdev区别不是很明白。

*** inotify
http://www.ibm.com/developerworks/cn/linux/l-inotifynew/index.html

inotify可以用于监控文件以及目录的变化，下面是inotify提供的API
   - #include <sys/inotify.h>
   - int inotify_init(void); // inotify_init1(0);
   - int inotify_init1(int flags);
     - IN_NONBLOCK // 在访问事件时候使用阻塞读取。
     - IN_CLOEXEC // 在exec时候关闭。
     - return a new file descriptor.
   - int inotify_add_watch(int fd, const char *pathname, uint32_t mask);
     - pathname // 需要监控的文件或者是目录
     - mask // 监控标记
     - return a nonnegative watch descriptor.
   - int inotify_rm_watch(int fd, int wd);

整个使用过程非常简单，首先通过init创建fd, 然后将需要监控的文件添加进来/或者是移除，之后在read时候读取监控事件。fd可以放在epoll里面进行监控。监控事件结构如下：
#+BEGIN_SRC C++
/* Structure describing an inotify event.  */
struct inotify_event
{
  int wd;		/* Watch descriptor.  */
  uint32_t mask;	/* Watch mask.  */
  uint32_t cookie;	/* Cookie to synchronize two events.  */
  uint32_t len;		/* Length (including NULs) of name.  */
  char name __flexarr;	/* Name.  */
};
#+END_SRC
 对于__flexarr这个字段是一个悬挂指针表示文件名称，文件长度通过len表示，所以读取一个event之后的话，还需要向前移动len个字节才能够读取下一个事件。

有下面这些事件可以进行监控。下面是代码
#+BEGIN_SRC C++
/* Supported events suitable for MASK parameter of INOTIFY_ADD_WATCH.  */
#define IN_ACCESS	 0x00000001	/* File was accessed.  */
#define IN_MODIFY	 0x00000002	/* File was modified.  */
#define IN_ATTRIB	 0x00000004	/* Metadata changed.  */
#define IN_CLOSE_WRITE	 0x00000008	/* Writtable file was closed.  */
#define IN_CLOSE_NOWRITE 0x00000010	/* Unwrittable file closed.  */
#define IN_CLOSE	 (IN_CLOSE_WRITE | IN_CLOSE_NOWRITE) /* Close.  */
#define IN_OPEN		 0x00000020	/* File was opened.  */
#define IN_MOVED_FROM	 0x00000040	/* File was moved from X.  */
#define IN_MOVED_TO      0x00000080	/* File was moved to Y.  */
#define IN_MOVE		 (IN_MOVED_FROM | IN_MOVED_TO) /* Moves.  */
#define IN_CREATE	 0x00000100	/* Subfile was created.  */
#define IN_DELETE	 0x00000200	/* Subfile was deleted.  */
#define IN_DELETE_SELF	 0x00000400	/* Self was deleted.  */
#define IN_MOVE_SELF	 0x00000800	/* Self was moved.  */

/* Events sent by the kernel.  */
#define IN_UNMOUNT	 0x00002000	/* Backing fs was unmounted.  */
#define IN_Q_OVERFLOW	 0x00004000	/* Event queued overflowed.  */
#define IN_IGNORED	 0x00008000	/* File was ignored.  */

/* Helper events.  */
#define IN_CLOSE	 (IN_CLOSE_WRITE | IN_CLOSE_NOWRITE)	/* Close.  */
#define IN_MOVE		 (IN_MOVED_FROM | IN_MOVED_TO)		/* Moves.  */

/* Special flags.  */
#define IN_ONLYDIR	 0x01000000	/* Only watch the path if it is a
					   directory.  */
#define IN_DONT_FOLLOW	 0x02000000	/* Do not follow a sym link.  */
#define IN_EXCL_UNLINK	 0x04000000	/* Exclude events on unlinked
					   objects.  */
#define IN_MASK_ADD	 0x20000000	/* Add to the mask of an already
					   existing watch.  */
#define IN_ISDIR	 0x40000000	/* Event occurred against dir.  */
#define IN_ONESHOT	 0x80000000	/* Only send event once.  */

/* All events which a program can wait on.  */
#define IN_ALL_EVENTS	 (IN_ACCESS | IN_MODIFY | IN_ATTRIB | IN_CLOSE_WRITE  \
			  | IN_CLOSE_NOWRITE | IN_OPEN | IN_MOVED_FROM	      \
			  | IN_MOVED_TO | IN_CREATE | IN_DELETE		      \
			  | IN_DELETE_SELF | IN_MOVE_SELF)

#+END_SRC
man里面对于每个事件有详细说明
#+BEGIN_EXAMPLE
   inotify events
       The  inotify_add_watch(2) mask argument and the mask field of the inotify_event structure returned when read(2)ing an ino‐
       tify file descriptor are both bit masks identifying inotify events.  The following bits can  be  specified  in  mask  when
       calling inotify_add_watch(2) and may be returned in the mask field returned by read(2):

           IN_ACCESS         File was accessed (read) (*).
           IN_ATTRIB         Metadata  changed,  e.g.,  permissions,  timestamps,  extended  attributes,  link count (since Linux
                             2.6.25), UID, GID, etc. (*).
           IN_CLOSE_WRITE    File opened for writing was closed (*).
           IN_CLOSE_NOWRITE  File not opened for writing was closed (*).
           IN_CREATE         File/directory created in watched directory (*).
           IN_DELETE         File/directory deleted from watched directory (*).
           IN_DELETE_SELF    Watched file/directory was itself deleted.
           IN_MODIFY         File was modified (*).
           IN_MOVE_SELF      Watched file/directory was itself moved.
           IN_MOVED_FROM     File moved out of watched directory (*).
           IN_MOVED_TO       File moved into watched directory (*).
           IN_OPEN           File was opened (*).

       When monitoring a directory, the events marked with an asterisk (*) above can occur for files in the directory,  in  which
       case the name field in the returned inotify_event structure identifies the name of the file within the directory.

       The  IN_ALL_EVENTS macro is defined as a bit mask of all of the above events.  This macro can be used as the mask argument
       when calling inotify_add_watch(2).

       Two additional convenience macros are IN_MOVE, which equates to IN_MOVED_FROM|IN_MOVED_TO, and IN_CLOSE, which equates  to
       IN_CLOSE_WRITE|IN_CLOSE_NOWRITE.

       The following further bits can be specified in mask when calling inotify_add_watch(2):

           IN_DONT_FOLLOW (since Linux 2.6.15)
                             Don't dereference pathname if it is a symbolic link.
           IN_EXCL_UNLINK (since Linux 2.6.36)
                             By  default,  when watching events on the children of a directory, events are generated for children
                             even after they have been unlinked from the directory.  This can result in large numbers of uninter‐
                             esting  events for some applications (e.g., if watching /tmp, in which many applications create tem‐
                             porary files whose names are immediately unlinked).  Specifying IN_EXCL_UNLINK changes  the  default
                             behavior,  so  that  events  are  not  generated for children after they have been unlinked from the
                             watched directory.
           IN_MASK_ADD       Add (OR) events to watch mask for this pathname if it already exists (instead of replacing mask).
           IN_ONESHOT        Monitor pathname for one event, then remove from watch list.
           IN_ONLYDIR (since Linux 2.6.15)
                             Only watch pathname if it is a directory.

       The following bits may be set in the mask field returned by read(2):

           IN_IGNORED        Watch was removed explicitly (inotify_rm_watch(2)) or automatically (file was deleted, or file  sys‐
                             tem was unmounted).
           IN_ISDIR          Subject of this event is a directory.
           IN_Q_OVERFLOW     Event queue overflowed (wd is -1 for this event).
           IN_UNMOUNT        File system containing watched object was unmounted.

#+END_EXAMPLE

在man 7 inotify里面给出了涉及到的内核参数
#+BEGIN_EXAMPLE
   /proc interfaces
       The following interfaces can be used to limit the amount of kernel memory consumed by inotify:

       /proc/sys/fs/inotify/max_queued_events
              The  value  in  this  file is used when an application calls inotify_init(2) to set an upper limit on the number of
              events that can be queued to the corresponding inotify instance.  Events in excess of this limit are  dropped,  but
              an IN_Q_OVERFLOW event is always generated.

       /proc/sys/fs/inotify/max_user_instances
              This specifies an upper limit on the number of inotify instances that can be created per real user ID.

       /proc/sys/fs/inotify/max_user_watches
              This specifies an upper limit on the number of watches that can be created per real user ID.
#+END_EXAMPLE
限制了创建的instance个数已经watch数目，以及event的数目。如果event出现溢出的话，那么会产生IN_Q_OVERFLOW事件。通常如果出现overflow事件的话，
以为着监控事件发生丢失，那么应用程序需要主动进行扫描。

** 标准IO
*** 流和定向
对于文件IO来说，所有IO函数都是针对文件描述符展开的。而对于标准IO而言，所有函数
都只针对流展开的。管理的结构是FILE,通常是一个结构体，通常里面包含了：
- 文件fd
- 缓冲区指针
- 缓冲区长度
- 当前缓冲区读取长度
- 出错标志
然后大部分标准IO使用的都是FILE*结构体指针来操作的。

使用函数fileno可以得到fd.而对于其他字段的话，因为本身就是一个struct结构，只需要
阅读stdio.h里面的FILE结构就可以看到每个字段的意思并且可以得到它们。

流的定向(stream's orientation)决定了所读写的字符是单字节还是多字节的。一个流最初
创建时并没有定向，直到第一次使用的时候才被确定。有两个函数可以设置流的定向：
- freopen.这个函数清除了流的定向。
- fwide(FILE* fp,int mode).这个函数修改流的定向。

#todo: 为什么需要使用宽字符。是否使用宽字符的话，那么很多编码方面的问题就可以在
标准IO层面操作而不需要上层操作呢？

对于文件IO使用了0,1,2分别表示标准输入，输出和错误，对应的标准IO也提供了预定义的
三个流来，分别是stdin,stdout和stderr.

*** 缓冲
标准IO相对于文件IO最便利的地方就是提供了缓冲。大部分情况下，缓冲能改善程序的性能，
虽然大部分使用标准IO需要提供一次额外的copy。

标准IO提供了下面三种缓冲：
- 全缓冲
- 行缓冲
- 不带缓冲

全缓冲是指填满IO缓冲区之后再进行实际IO操作，通常来说对于驻留在磁盘上的文件使用
全缓冲。在流上第一次实行IO操作的时候，标准IO就会通过malloc分配一块缓冲区。如果使用
全缓冲需要强制进行实际操作的话，可以调用fflush来冲刷。对于flush有两层意思，对于
标准IO而言，flush是将缓冲区的内容进行实际IO操作，而对于设备驱动程序而言，就是
丢弃缓冲区里面的内容。

#+BEGIN_SRC c
#include <cstdio>
#include <unistd.h>
int main(){
    //退出后输出
    char buffer[1024];
    setvbuf(stdout,buffer,_IOFBF,sizeof(buffer));
    printf("helloworld");
    sleep(2);
    return 0;
}
#+END_SRC

行缓冲是指输入和输出遇到换行符之后，标准IO库才执行IO操作。当然如果缓冲区已经满了
的话，那么也是会进行的。并且任何时候如果标准IO库从一个不带缓冲的流，或者是从内核
得到数据的带行缓冲流中获得数据的话，会造成冲洗所有行缓冲输出流。(what fucking is that?).
通常来说对于终端设备比如标准输入和输出的时候，使用行缓冲。
#+BEGIN_SRC C++
#include <cstdio>
#include <unistd.h>
int main(){
    //退出后输出
    char buffer[128];
    setvbuf(stdout,buffer,_IOLBF,sizeof(buffer));
    printf("helloworld");
    sleep(2);
    return 0;
}
#+END_SRC
#+BEGIN_SRC C++
#include <cstdio>
#include <unistd.h>
int main(){
    //立刻输出
    char buffer[128];
    setvbuf(stdout,buffer,_IOLBF,sizeof(buffer));
    printf("helloworld\n");
    sleep(2);
    return 0;
}
#+END_SRC
#+BEGIN_SRC C++
#include <cstdio>
#include <unistd.h>
int main(){
    //立刻输出
    //可以看到并不是说缓冲区足够的情况下不输出
    //内置有另外一套算法，对于128那么就并没有输出
    //而对于64立刻输出，但是其实都没有填满
    char buffer[64];
    setvbuf(stdout,buffer,_IOLBF,sizeof(buffer));
    printf("helloworld");
    sleep(2);
    return 0;
}
#+END_SRC
关于行缓冲这个部分确实很迷惑人:(.

不带缓冲是指不对字符进行任何缓冲。通常对于标准错误来说，希望信息尽可能地快地显示
出来，所以不带缓冲。

对于Linux平台来说：
   - 标准错误是不带缓冲的。
   - 终端设备是行缓冲的。
   - 其他都是全缓冲的。
也提供了API来设置缓冲模式：
#+BEGIN_SRC C++
//打开和关闭缓冲模式
//如果buf!=NULL,buf必须是BUFSIZE大小缓冲区，那么选择合适的缓冲模式
//如果buf==NULL,那么表示不带缓冲
void setbuf(FILE* restrict fp,char* restrict buf);

//mode可以执行什么缓冲模式
//如果不带缓冲，那么忽略buf和isze
//如果带缓冲，那么使用buf和size.如果buf==NULL,那么size=BUFSIZE
int setvbuf(FILE* restrict fp,char* restrict buf,int mode,size_t size);
#+END_SRC

关于fflush也之前也提过了，如果fflush传入参数为NULL的话，那么会刷出所有的输出流。

可以看到，标准IO提供了很多一次刷新所有输出流(fflush)和一次刷新所有行输出流，并且
如果程序退出之前没有关闭流的话，那么标准IO会自动帮助我们关闭。那么基本上可以了解，
在实现层面上，我们打开一个流对象，在标准IO都会进行簿记的。

*** 打开和关闭流
打开流提供了下面这些函数：
#+BEGIN_SRC C++
//打开pathname
FILE* fopen(const char* restrict pathname,const char* restrict type);
//关闭fp,然后打开pathname,和fp进行关联
FILE* freopen(const char* restrict pathname,const char* restrict type,FILE* restrict fp);
//将打开的fd映射成为流
FILE* fdopen(int fd,const char* type);
#+END_SRC
通常来说freopen的用途是，将fp设置成为stdin,stdout或者是stderr,这样原来操作fprintf
函数的话，就可以直接关联到文件上面了，而不需要修改很多代码即可完成。

关于type有下面这几种枚举值
| type       | 说明                         |
|------------+------------------------------|
| r/rb       | 读打开                       |
| w/wb       | 截断写打开，如果不存在创建   |
| a/ab       | 追加写打开，如果不存在创建   |
| r+/r+b/rb+ | 读写打开                     |
| w+/w+b/wb+ | 截断读写打开，如果不存创建   |
| a+/a+b/ab+ | 追加读写打开，如果不存在创建 |
对于fdopen的type比较特殊，type不能够指定创建还是截断，并且关于读写模式必须和fd的
属性相同。

因为标准IO内部只是维护一个缓冲区，如果读写交替的话，那么实际上会打乱内部buffer
内容。所以如果使用+打开的话，在交替输出和输入的时候，需要进行flush操作，可以使用
下面这些函数：
- fseek
- fseeko
- fsetpos
- rewind
- fflush

关于流使用fclose函数，在文件关闭之前会冲洗缓冲区的输出数据，并且丢弃缓冲区的任何输
入数据。并且如果IO库已经分配一个缓冲区的话，那么需要显示地释放这块缓冲区。

*** 读写流
**** 字符IO
包括下面这些：
#+BEGIN_SRC C++
int getc(FILE* fp);
int fgetc(FILE* fp);
int getchar();
int ungetc(int c,FILE* fp); //回退到流
int putc(int c,FILE* fp);
int fputc(int c,FILE* fp);
int putchar();
#+END_SRC
其中getc和fgetc,以及putc和fputc的差别就是,getc/putc可以实现为宏，而fgetc和fputc必
须是函数，我们可以得其地址。

对于get函数来说，我们返回的是int.如果达到末尾或者是出错的话，那么就会返回EOF(-1).
为了判断是因为出错还是因为文件结束的话，我们可以使用函数：
- feof
- ferror
文件FILE里面记录了结束位和出错位，调用clearerr可以清除。

使用ungetc可以回退一个字符到流中。回退的字符不允许是EOF,如果回退成功的话，那么会
清除该流文件的文件结束标志。

**** 行IO
包括下面这些：
#+BEGIN_SRC C++
char* fgets(char* restrict buf,int n,FILE* restrict fp);
char* gets(char* buf);
int fputs(const char* restrict str,FILE* restrict fp);
int puts(const char* str);
#+END_SRC
我们尽量避免使用gets这样的函数。对于fxxx和xxx之间一个最重要的区别是，fxxx需要我们自己
来处理换行符，而xxx自动帮助我们处理了换行符。

**** 二进制IO
包括下面这些：
#+BEGIN_SRC C++
//其中size表示一个对象的大小，nobj表示需要读取多少个对象
size_t fread(void* restrict ptr,size_t size,size_t nobj,FILE* restrict fp);
size_t fwrite(const void* restrict ptr,size_t size,size_t nobj,FILE* restrict fp);
#+END_SRC
返回值表示读写对象个数，如果==0的话，那么需要判断出错还是文件结束。

**** 格式化IO
输出包括下面这些函数：
   - printf
   - fprintf
   - sprintf
   - snprintf
   - vprintf
   - vfprintf
   - vsprintf
   - vsnprintf
输入包括下面这些函数：
   - scanf
   - fscanf
   - sscanf
   - vscanf
   - vfscanf
   - vsscanf
里面最重要的就是format格式，但是了解format格式非常tedious并且获益并不是很大，如果需要
设计某种小型的数据驱动语言的话，可以参考这个东西非常有帮助。

*** 定位流
包括下面这些：
#+BEGIN_SRC C++
long ftell(FILE* fp);
off_t ftello(FILE* fp);

//whence包括
//SEEK_SET 从头
//SEEK_CUR 当前
//SEEK_END 末尾
int fseek(FILE* fp,long offset,int whence);
int fseeko(FILE* fp,off_t offset,int whence);

//回到头部
void rewind(FILE* fp);

//如果移植到非UNIX平台建议使用
int fgetpos(FILE* restrict fp,fpos_t* restrict pos);
int fsetpos(FILE* fp,const fpos_t* pos);
#+END_SRC
其中ftello/ftell和fseeko/fseek之间的差别，就是类型不同，分别是off_t和long.

*** 临时文件
创建临时文件的接口有：
#+BEGIN_SRC C++
char* tmpnam(char* ptr);
FILE* tmpfile(void);
char* tempnam(const char* directory,const char* prefix);
int mkstemp(char* template);
#+END_SRC

tmpnam的ptr传入一个L_tmpnam长度的buf,然后会返回一个临时文件的名称，最多调用TMP_MAX次。
#+BEGIN_SRC C++
#include <cstdio>
int main(){
    char name[L_tmpnam];
    printf("%d\n",TMP_MAX);
    for(int i=0;i<10;i++){
        name[0]=0;
        tmpnam(name);
        printf("%s\n",name);
    }
    return 0;
}
#+END_SRC
临时文件目录都是在/tmp目录下面的
#+BEGIN_EXAMPLE
[dirlt@localhost.localdomain]$ ./main
238328
/tmp/fileroni3c
/tmp/filehspHQc
/tmp/file5Us9Dc
/tmp/file4gKJrc
/tmp/fileKgUsfc
/tmp/file3wqf3b
/tmp/fileTDb5Qb
/tmp/fileGCrXEb
/tmp/filexBfVsb
/tmp/filepoJVgb
#+END_EXAMPLE

tmpfile可以返回一个"wb+"打开临时文件流。基本上可以认为tmpfile是这样操作的：
   - tmpname产生一个文件名
   - 然后fopen(...,"wb+")打开
   - 然后unlink这个文件
但是因为这种间存在一定的时间空隙，tmpfile保证原子操作行。并且注意到最后unlink了，
所以不需要用来自己删除文件:).

tempnam相对于tmpnam来说功能更强大，但是至于是否好用就不好说了。对于tempnam可以在
不同目录下面生成临时文件(顺序比较诡异):
   - 如果有环境变量TMPDIR,那么在directory为TMPDIR.
   - 如果directory不为NULL的话，那么使用directory.
   - <cstdio>定义的P_tmpdir.
而prefix是最多包含5个字符的字符串。然后内部使用malloc来构造，所以最终需要自己释放。
#+BEGIN_SRC C++
#include <cstdio>
#include <cstdlib>
#include <unistd.h>
int main(){
    printf("%s\n",P_tmpdir);
    //只取前面5个字符
    char* p=tempnam("/var/tmp","helloworld");
    printf("%s\n",p);
    free(p);
    p=tempnam(NULL,"helloworld");
    printf("%s\n",p);
    free(p);
    return 0;
}
#+END_SRC
#+BEGIN_EXAMPLE
[dirlt@localhost.localdomain]$ ./main
/tmp
/var/tmp/hello7wVj3K
/tmp/helloqNEpql
[dirlt@localhost.localdomain]$ TMPDIR=/home/ ./main
/tmp
/home/hellopg7ANi
/home/hello1xmviW
#+END_EXAMPLE

mkstemp要求template是一个路径名称，最后面是6个XXXXXX,然后会修改这6个字符。然后
一旦创建成功之后返回文件描述符就可以使用。但是需要注意的是，mkstemp相对于tmpfile
并不会自动进行unlink,所以需要用户自己进行unlink.

** 系统数据文件和信息
Unix系统正常允许需要使用大量和系统相关的数据文件，有些数据文件是ASCII文件有些
是二进制文件，但是为了方便接口来处理，所以提供一系列访问的接口。

*** 口令文件
口令文件存储于/ect/passwd下面，每一行是一个记录按照:进行分隔：
#+BEGIN_EXAMPLE
gopher:x:13:30:gopher:/var/gopher:/sbin/nologin
ftp:x:14:50:FTP User:/:/sbin/nologin
nobody:x:99:99:Nobody:/:/sbin/nologin
dbus:x:81:81:System message bus:/:/sbin/nologin
#+END_EXAMPLE
之前提到过每个字段含义。可以看到密码都是使用x表示。如果不希望用户登录的话，那么
提供一个不存在的shell比如/sbin/noshell或者是/sbin/nologin.

所涉及到的结c
#+BEGIN_SRC c
#include <pwd.h>
struct passwd {
    char    *pw_name;      /* user name */
    char    *pw_passwd;    /* user password */
    uid_t   pw_uid;        /* user id */
    gid_t   pw_gid;        /* group id */
    char    *pw_gecos;     /* real name */
    char    *pw_dir;       /* home directory */
    char    *pw_shell;     /* shell program */
};

//按照uid和name来进行查找
//内部实现可以理解为使用下面例程来完成的
struct passwd* getpwuid(uid_t uid);
struct passwd* getpwnam(const char* name);

//得到下一个entry.如果没有打开文件会自动打开
//不是线程安全的
struct passwd* getpwent(void);

//从头开始entry
void setpwent(void);
//关闭entry访问接口
void endpwent(void);
#+END_SRC

#+BEGIN_SRC c
#include <pwd.h>
#include <cstdio>
int main(){
    setpwent();
    struct passwd* pw=getpwent();
    while(pw){
        printf("%s:%s:%d:%d:%s:%s:%s\n",
               pw->pw_name,pw->pw_passwd,pw->pw_uid,pw->pw_gid,
               pw->pw_gecos,pw->pw_dir,pw->pw_shell);
        pw=getpwent();
    }
    endpwent();
    return 0;
}
#+END_SRC

*** 阴影口令
虽然密码是进行单向加密算法加密的，但是如果攻击者进行密码碰撞检测的话，并且配合
工程学的知识来破解的话，相对来说比较容易破解。所以之后Unix系统将单向加密值放在
/etc/shadow文件下面，这个文件只有root可以阅读。格式和/etc/shadow一样：
#+BEGIN_EXAMPLE
root:$1$s4hs87U1$ti.Gd2Nh/JiQ6L.SuSg7L1:14927:0:99999:7:::
dirlt:$1$BRt79uEo$PtCKwZNuUB7x5zyOKVRi00:14927:0:99999:7:::
#+END_EXAMPLE

访问结构和接口有下面这些：
#+BEGIN_SRC c
#include <shadow.h>
struct spwd {
    char          *sp_namp; /* user login name */
    char          *sp_pwdp; /* encrypted password */
    long int      sp_lstchg; /* last password change */
    long int      sp_min; /* days until change allowed. */
    long int      sp_max; /* days before change required */
    long int      sp_warn; /* days warning for expiration */
    long int      sp_inact; /* days before account inactive */
    long int      sp_expire; /* date when account expires */
    unsigned long int  sp_flag; /* reserved for future use */
};
//使用name查找，底层还是调用下面拿几个函数
struct spwd* getspnam(const char* name);
struct spwd* getspent();
void setspent();
vodi endspent();
#+END_SRC

*** 组文件
格式和/etc/passwd一样，最后一个字段按照,分开：
#+BEGIN_EXAMPLE
root:x:0:root
bin:x:1:root,bin,daemon
daemon:x:2:root,bin,daemon
sys:x:3:root,bin,adm
adm:x:4:root,adm,daemon
tty:x:5:
dirlt:x:500
#+END_EXAMPLE

结构和接口有下面这些：
#+BEGIN_SRC c
#include <grp.h>
struct group {
    char   *gr_name;       /* group name */
    char   *gr_passwd;     /* group password */
    gid_t   gr_gid;        /* group ID */
    char  **gr_mem;        /* group members */
};
//按照gid和group name来检索
struct group* getgrgid(gid_t gid);
struct group* getgrnam(const char* name);
//遍历接口
struct group* getgrent();
void setgrent();
void endgrent();
#+END_SRC
#+BEGIN_SRC c
#include <grp.h>
#include <cstdio>
int main(){
    setgrent();
    struct group *gp=getgrent();
    while(gp){
        printf("%s:%s:%d:",gp->gr_name,gp->gr_passwd,gp->gr_gid);
        if(*(gp->gr_mem)){
            while(*(gp->gr_mem+1)){
                printf("%s,",*(gp->gr_mem));
                gp->gr_mem++;
            }
            printf("%s",*(gp->gr_mem));
        }
        printf("\n");
        gp=getgrent();
    }
    endgrent();
    return 0;
}
#+END_SRC

*** 其他数据文件
其他数据文件所提供的接口和上面很相似，包括遍历接口和查找接口。
| 说明     | 数据文件       | 头文件     | 结构     | 查找函数              |
|----------+----------------+------------+----------+-----------------------|
| 口令     | /etc/passwd    | <pwd.h>    | passwd   | getpwnam,getpwuid     |
| 组       | /etc/group     | <grp.h>    | group    | getgrnam,getgrgid     |
| 阴影文件 | /etc/shadow    | <shadow.h> | spwd     | getspnam              |
| 主机     | /etc/hosts     | <netdb.h>  | hostent  | gethostbyname/addr    |
| 网络     | /etc/networks  | <netdb.h>  | netent   | getnetbyname/addr     |
| 协议     | /etc/protocols | <netdb.h>  | protoent | getprotobyname/number |
| 服务     | /etc/services  | <netdb.h>  | servent  | getservbyname/port    |

*** 登录账户记录
Unix提供了下面这两个数据文件utmp和wtmp.其中utmp记录当前登录进入系统的各个用户，
而wtmp是跟踪各个登录和注销事件，内部都是相同的二进制记录。在Linux系统上，两个
文件的存放位置分别是/var/run/utmp和/var/log/wtmp,查看man utmp可以查看二进制的
格式：
#+BEGIN_SRC c
struct exit_status {
    short int e_termination;    /* process termination status */
    short int e_exit;           /* process exit status */
};

struct utmp {
    short ut_type;              /* type of login */
    pid_t ut_pid;               /* PID of login process */
    char ut_line[UT_LINESIZE];  /* device name of tty - "/dev/" */
    char ut_id[4];              /* init id or abbrev. ttyname */
    char ut_user[UT_NAMESIZE];  /* user name */
    char ut_host[UT_HOSTSIZE];  /* hostname for remote login */
    struct exit_status ut_exit; /* The exit status of a process
                                   marked as DEAD_PROCESS */

    /* The ut_session and ut_tv fields must be the same size when
       compiled 32- and 64-bit.  This allows data files and shared
       memory to be shared between 32- and 64-bit applications */
#if __WORDSIZE == 64 && defined __WORDSIZE_COMPAT32
    int32_t ut_session;         /* Session ID, used for windowing */
    struct {
        int32_t tv_sec;         /* Seconds */
        int32_t tv_usec;        /* Microseconds */
    } ut_tv;                    /* Time entry was made */
#else
    long int ut_session;        /* Session ID, used for windowing */
    struct timeval ut_tv;       /* Time entry was made */
#endif

    int32_t ut_addr_v6[4];       /* IP address of remote host */
    char __unused[20];           /* Reserved for future use */
};
#+END_SRC

登录时，login进程填写此结构，写入utmp和wtmp文件中，注销时init进程将utmp
文件中对应记录擦除并且增加一条新记录到wtmp文件中。并且在系统重启，修改系统
时间和日期之后，都会在wtmp文件中追加一条记录。

utmp和wtmp虽然都是二进制文件，但是Linux系统了系统命令可以用来查看这两个
文件，分别是who和last.:).

*** 系统标识
uname函数可以返回和当前主机和操作系统相关信息：
#+BEGIN_SRC c
#include <sys/utsname.h>
int uname(struct utsname *buf);
struct utsname {
    char sysname[];
    char nodename[];
    char release[];
    char version[];
    char machine[];
#ifdef _GNU_SOURCE
    char domainname[];
#endif
};
#+END_SRC

需要注意的是nodename不能够用于引用网络通信主机，仅仅适用于引用UUCP网络上的主机。
如果需要返回TCP网络主机的话，可以使用gethostname这个函数：

#+BEGIN_SRC c
#include <unistd.h>
int gethostname(char* name,int namelen);
#+END_SRC

#+BEGIN_SRC c
#include <sys/utsname.h>
#include <unistd.h>
#include <cstdio>
int main(){
    struct utsname buf;
    uname(&buf);
    printf("sysname:%s\n"
           "nodename:%s\n"
           "release:%s\n"
           "version:%s\n"
           "machine:%s\n"
           "domainname:%s\n",
           buf.sysname,buf.nodename,
           buf.release,buf.version,
           buf.machine,buf.domainname);
    char host[128];
    gethostname(host,sizeof(host));
    printf("hostname:%s\n",host);
    return 0;
}
#+END_SRC

#+BEGIN_EXAMPLE
[dirlt@localhost.localdomain]$ ./main
sysname:Linux
nodename:localhost.localdomain
release:2.6.23.1-42.fc8
version:#1 SMP Tue Oct 30 13:55:12 EDT 2007
machine:i686
domainname:(none)
hostname:localhost.localdomain
#+END_EXAMPLE

*** 时间和日期例程
Unix所提供的时间和日期是存放在一个量值里面的，就是time_t.表示从国际标准时间1970年
1月1日00:00:00至今的秒数，使用调用time可以获得。当然Unix也提供了一系列的函数来进行
转换和本地化操作，包括夏时制转换以及转换成为本地时区的时间。当然Unix也提供了更加
精确到微妙的调用gettimeofday。

#+BEGIN_SRC c
struct timeval{
    time_t tv_sec; //这个分量还是表示秒
    long tv_usec; //微秒
};
#+END_SRC

time_t是一个秒的概念，Unix还提供了下面结构可以表达日期时间概念：
#+BEGIN_SRC c
struct tm {
    int tm_sec;         /* seconds */ //[0,60]60表示闰秒
    int tm_min;         /* minutes */
    int tm_hour;        /* hours */
    int tm_mday;        /* day of the month */
    int tm_mon;         /* month */
    int tm_year;        /* year */ //since 1900
    int tm_wday;        /* day of the week */
    int tm_yday;        /* day in the year */
    int tm_isdst;       /* daylight saving time */ //>0夏时制生效
};
#+END_SRC
当然得到这个结构用户还必须自己制作字符串，所以还有字符串表达方式(const char*)。

| from      | to          | function  | 受TZ影响 |
|-----------+-------------+-----------+----------|
| time_t    | struct tm   | gmtime    | 否       |
| time_t    | struct tm   | localtime | 是       |
| struct tm | time_t      | mktime    | 否       |
| time_t    | const char* | ctime     | 是       |
| struct tm | const char* | asctime   | 否       |
| struct tm | const char* | strftime  | 是       |
受TZ影响的意思是受环境变量TZ的影响，TZ可以用来定义我们系统所处的时区。

** 进程
*** 命令行参数和环境表
进程参数表argv和环境变量表environment的最后一个表项都是NULL。

进程参数和环境变量都是安排在内存空间高端的。当putenv需要向环境表增加内容时，原则上
尽可能复用内存，但是，当环境变量表的表项不够时，需要用malloc开辟新的环境变量表，
然后，复制各表项，并修改全局指针变量environment；当原来存放环境变量的进程栈顶空间
不够时，需要调用malloc为新表项开辟新空间，并相应更新环境变量表的表项。

*** 资源限制
每个进程都有一组资源限制，可以设置和查看这些资源限制。
#+BEGIN_SRC C++
#include <sys/resource.h>
int getrlimit(int resource,struct rlimit* limit);
int setrlimit(int resource,const struct rlimit* limit);
struct rlimit{
    rlim_t rlim_cur; //soft limit,current limit.
    rlim_t rlim_max; //hard limit,maximum value for rlim_cur.
};
#+END_SRC
对于资源限制分为硬限制和软限制，遵循下面三个规则：
- 任何进程都可以将软限制调整<=硬限制。
- 任何进程可以降低硬限制，但是必须>=软限制。
- 只有超级用户可以提高硬限制。
常量RLIM_INFINITY可以指定无限量限制。

关于resoruce有下面这几个常量：
| 常量              | 说明                                                 |
|-------------------+------------------------------------------------------|
| RLIMIT_AS         | 进程可用存储区最大总长度，影响sbrk和mmap             |
| RLIMIT_CORE       | core文件最大字节数                                   |
| RLIMIT_CPU        | CPU使用的最大值，单位秒                              |
| RLIMIT_DATA       | 数据段最大值，包括初始化未初始化数据和堆总和         |
| RLIMIT_FSIZE      | 可以创建文件最大字节数，如果超过限制发送SIGXFSZ信号  |
| RLIMIT_LOCKS      | 进程持有的文件锁最大数                               |
| RLIMIT_MEMLOCK    | 使用mlock锁定的最大字节长度                          |
| RLIMIT_MSGQUEUE   | message queue允许分配的最大字节数                    |
| RLIMIT_NICE       | 进程允许调整到的最高nice value                       |
| RLIMIT_NOFILE     | 进程能够打开文件最大数                               |
| RLIMIT_NPROC      | 每个实际用户ID可拥有的最大进程数                     |
| RLIMIT_RSS        | 最大驻内存的字节长度(resident set size in bytes,RSS) |
| RLIMIT_RTPRIO     | 每个进程设置的实施优先级的最大值                     |
| RLIMIT_SIGPENDING | 排队信号的最大值                                     |
| RLIMIT_SBSIZE     | 用户占用的内核socket bufer最大长度                   |
| RLIMIT_STACK      | 栈的最大字节长度                                     |
| RLIMIT_VMEM       | 和RLIMIT_AS相同                                      |


#+BEGIN_EXAMPLE
[dirlt@localhost.localdomain]$ ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 4096
max locked memory       (kbytes, -l) 32
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 10240
cpu time               (seconds, -t) unlimited
max user processes              (-u) 4096
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
#+END_EXAMPLE

*** 进程标识符
进程标识符接口有下面这些：
- getpid //pid
- getppid //parent pid
- getuid //实际用户id
- geteuid //有效用户id
- getgid //实际组id
- getegid  //有效组id

*** 非局部跳转
#<<非局部跳转>>

非局部跳转就是指函数之间的跳转了，使用的函数是：
#+BEGIN_SRC c
#include <setjmp.h>
int setjmp(jmp_buf env);
void longjmp(jmp_buf env,int val);
#+END_SRC
定义一个全局的jmp_buf。在希望返回的位置调用setjmp(jmp_buf)，其将返回0。调用
longjmp(jmp_buf, val)，则将跳回到调用setjmp(jmp_buf)的位置，且setjmp将再次
返回，返回值将是val。longjmp(jmp_buf, val)可多次被调用，但应该使用不同的val。

当跳回到调用setjmp的地方后，全局变量、该scope内的局部静态变量、该scope内的
volatile变量都不会被回滚到之前调用setjmp时的相应值，而该scope内的普通局部变量
则不一定，则将依赖于编译器优化等。

怎样处理信号屏蔽字，这里并没有规定，所以，需要使用[[sigsetjmp][sigsetjmp/siglongjmp]]
*** 开辟子进程
fork出来的子进程有独立的进程地址空间，相应的物理内存与父进程通过COW的方式共享。

父进程已打开的文件描述符会被子进程继承，包括文件描述符标志O_CLOLEXEC和指向文件
表项的指针，但它们都不是父子进程共享的，父子进程共享的是被父子进程分别通过各自的
指针引用到的文件表项，其中，记录了文件状态标志及当前文件偏移量，所以，当父子进程
并发写时，会引起的混乱, 为避免，常见的做法有以下两种，
- 在fork()之后，父进程等待子进程完成。
- 在fork()之后，父子进程分别关闭不需要的文件。

子进程继承的属性还有：
- uid,gid,euid,egid
- 附加组id,进程组id,会话id
- 设置用户id(set-user-id)标记和设置组id标记(set-group-id)
- 控制终端
- 当前工作目录/根目录
- 文件创建时的模式屏蔽字
- 信号屏蔽字和信号处理函数
- 环境变量
- 共享内存
- 内存映射
- 资源限制

下面是不同的部分：
- pid不同，父进程的pid也不同
- 进程时间被清空
- 文件锁没有继承
- 未处理信号被清空

*** 进程终止
- 正常终止
  - main返回.
  - exit.
    标准IO(ISO C)。执行atexit注册的函数，输出流缓冲中所有的数据，关闭所有打开的
    流，最终，会调用_exit函数去关闭所有打开的文件描述符，并释放所用内存。
  - _exit/_Exit
    这两者间并无差别，前者是Posix标准，后者是ISO C标准。都是直接陷入内核。
    它们的参数就是退出状态，最终，父进程可以获得该状态值。
  - 最后一个线程从启动例程返回。
    进程返回的终止状态为0，而与最后一个线程的返回值无关。
  - 最后一个线程调用pthread_exit.
    进程返回的终止状态为0，而与这里pthread_exit的调用参数无关。
- 异常终止
  - abort.
  - 接收到信号并且终止。
    信号可能来源于进程自身、其他进程或内核。
  - 最后一个线程对取消请求作出响应。

atexit函数是ISO C标准定义的，用于注册进程终止时的处理程序（一个进程最多32个），由
exit自动调用，调用顺序与注册顺序相反。

如果父进程在子进程之前结束，则子进程会成为孤儿进程，孤儿进程的父进程会被内核改为
init进程。

*** 等待子进程结束
#+BEGIN_SRC c
#include <sys/wait.h>
pid_t wait(int* statloc);
pid_t waitpid(pid_t pid,int* statloc,int options);
#+END_SRC

这些系统调用用于等待子进程的状态改变，包括
- 子进程终止
  父进程可以调用wait/waitpid去获得子进程的信息，包括进程ID,终止状态以及占用CPU时间
  等，同时，会释放掉子进程的进程控制块task_struct，从而，最终干掉一个进程。如果父
  进程一直存在，但一直都没有对某终止了的子进程调用wait/waitpid，则该终止了的子进程
  将成为僵尸进程。
- 被(通过ptrace)跟踪的子进程在收到除SIGKILL外的任何信号时
  子进程会暂停，且这两系统调用也都将返回。
  因此而被暂停了的子进程是无法用信号SIGCONT让其继续执行的，需要跟踪进程使用参数
  PTRACE_CONT再次调用ptrace。

这些系统调用将被阻塞，直到
- 调用进程没有任何子进程，则出错返回。
- 子进程的状态发生改变。
  - 对于wait，是任意一子进程的状态发生改变。
  - 对于waitpid，是参数pid指定的子进程（或进程组中的任一子进程）的状态发生改变。
- 系统调用被信号处理函数中断。

参数options，
- WNOHANG. 
  非阻塞的等待子进程结束。
- WUNTRACED. 
  该选项对被跟踪的子进程无意义。
  若调用waitpid时使用了WUNTRACED选型，则未被跟踪的子进程暂停时，waitpid也会返回，
  否则，只见被暂停的子进程恢复运行，却不见waitpid的返回。
- WCONTINUED.
  此选项对被跟踪的子进程无用。
  设置该选项，则子进程被信号SIGCONT恢复运行时，只见子进程恢复运行，不见waitpid返回。
  设置该选项，收到SIGCONT后，则可见子进程恢复运行，且waitpid也将返回。

#+BEGIN_SRC c
#include <sys/wait.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/ptrace.h>

int main(int argc, char *argv[]) {
   pid_t cpid, w;
   int status;

   cpid = fork();
   if (cpid == -1) {
       perror("fork");
       exit(EXIT_FAILURE);
   }
   if (cpid == 0) {            /* Code executed by child */
       //ptrace(PTRACE_TRACEME, 0, NULL, NULL);
       printf("Child PID is %ld\n", (long) getpid());
       if (argc == 1)
           pause();                    /* Wait for signals */
       _exit(atoi(argv[1]));
   } else {                    /* Code executed by parent */
       do {
         w = waitpid(cpid, &status, WCONTINUED | WUNTRACED);
         //w = wait(&status);
           if (w == -1) {
               perror("waitpid");
               exit(EXIT_FAILURE);
           }
           if (WIFEXITED(status)) {
               printf("exited, status=%d\n", WEXITSTATUS(status));
           } else if (WIFSIGNALED(status)) {
               printf("killed by signal %d\n", WTERMSIG(status));
           } else if (WIFSTOPPED(status)) {
               printf("stopped by signal %d\n", WSTOPSIG(status));
           } else if (WIFCONTINUED(status)) {
               printf("continued\n");
           }
          //ptrace(PTRACE_CONT, cpid, NULL, NULL);
       } while (!WIFEXITED(status) && !WIFSIGNALED(status));
       exit(EXIT_SUCCESS);
   }
}
#+END_SRC

参数statloc用于存放子进程的返回信息，通过宏来处理这个值：
- WIFEXITED(status)
  子进程正常终止。
  可用宏WEXITSTATUS获得子进程的返回状态。
- WIFSIGNALED(status)
  进程因信号而终止。
  可用宏WTERMSIG获取该信号。
  可用宏WCOREDUMP检查子进程是否产生core dump。
- WIFSTOPPED(status)
  子进程被暂停。
  发生的前提是，使用选项WUNTRACED调用waitpid，或者，子进程是被跟踪的。
  使用宏WSTOPSIG可获得使子进程暂停的信号。
- WIFCONTINUED(status)
  被暂停的子进程因SIGCONT而恢复执行。

wait函数的返回值。成功时，返回子进程的pid。失败时，返回-1，可以查看errno变量, 
其中，ECHILD表示没有子进程了。

waitpid函数的返回值。成功时，返回子进程pid。如果指定的被等待的子进程（或进程组）
都没有发生状态改变，返回0。失败时，返回-1，可查看errno，其中，ECHLD表示没有符合
等待条件的子进程（或进程组）。

父进程能否收到SIGCHLD与[[SA_NOCLDSTOP][SA_NOCLDSTOP]]有关。

父进程对SIGCHLD的默认处理是忽略，但是，会产生僵尸进程。父进程可以多次直接调用wait
函数以等待多个子进程的结束，但是，每次调用wait都会阻塞父进程。父进程可以通过
WNOHANG选项多次直接调用waitpid函数以等待多个子进程的结束，这样，虽不会阻塞父进程，
但是，会多次发生无功的系统调用。 父进程可以选择对SIGCHLD显式忽略，这样就不会产生僵
尸进程。父进程也可以对SIGCHLD自定义信号处理函数，但是，由于Linux不支持信号排队，多
次发生的同一个信号只会被处理一次，也就是说，并不是每个子进程的退出，都会相应地触发
一次自定义的信号处理函数，所以，在信号处理函数中，应该循环调waitpid以最终结束
当前已结束的每个子进程。注意，这里不调用wait的原因是，wait函数会一直等着本次信号处
理函数执行时的、所有的已结束的子进程和所有的还未结束的子进程，所以，会使得父进程
被阻塞在信号处理函数中。对于不会出现子进程同时终止的情况，还有一种办法可以既不产生
僵死进程，同时又可获得子进程终止状态的方法，具体参考[[SA_NOCLDWAIT][SA_NOCLDWAIT]] .
#+BEGIN_SRC c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>

void wait4children(int signo) {
  int status;
  // for the difference below, check clone() and wait4() printed by strace ./a.out
  while(wait(&status)>0);
  //while(waitpid(-1, &status, WNOHANG)>0);
}

int main(int argc, char *argv[]) {
  pid_t cpid;

  // signal(SIGCHLD, SIG_IGN);
  signal(SIGCHLD, wait4children);

  for(int i=0; i<100; i++) {
    cpid = fork();
    if(cpid==0) {
      break;
    }
  }

  if(cpid>0) {
    printf("Press any key to exit ...");
    getchar();
  }
  return 0;
}
#+END_SRC

为获得资源统计信息，可以使用wait3/wait4函数。
#+BEGIN_SRC c
pid_t wait3(int* statloc,int options,struct rusage* rusage);
pid_t wait4(pid_t pid,int* statloc,int options,struct rusage* rusage);
#+END_SRC

*** exec函数
exec所做的事情就是替换当前正文段，数据，堆和栈。exec族函数包括：
#+BEGIN_SRC c
int execl(const char* pathname,const char* arg0,.../* (char *)0 */); 
int execv(const char* pathname,char* const argv[]); 
int execle(const char* pathname,const char* arg0,.../* (char *)0, char *envp[] */);
int execve(const char* pathname,char* const argv[],char* const envp);
int execlp(const char* filename,const char* arg0,.../* (char *)0 */); 
int execvp(const char* filename,char* const argv[]); 
int fexecve(int fd, char *const argv[], char *const envp[]);
#+END_SRC
通过参数envp，可以指定子进程的环境变量，而非使用父进程的环境变量。
对于exec来说，如果传入的是filename的话，那么：
- 如果包含/的话，那么认为这是一个路径名pathname
- 否则在PATH环境变量里面查找到第一个可执行文件
- 如果可执行文件不是链接器产生的话，那么认为是一个shell文件，使用/bin/sh执行

执行exec函数时，下面属性是不发生变化的：
- 进程ID和父进程ID
- 实际用户ID和实际组ID
- 附加组ID
- 会话ID
- 控制终端
- 闹钟余留时间
- 当前工作目录
- 根目录
- umask
- 文件锁
- 进程信号屏蔽
- 未处理信号
- 资源限制
- 进程时间

执行exec函数时，发生变化的属性：
- 文件描述符如果存在close-on-exec标记(CLOEXEC)的话，那么会关闭。
- 若可执行文件存在设置用户ID(set-user-id)和组ID位(set_group_id)，则有效用户ID和组ID会发生变化。
- 原来被捕捉的信号，会被设置为默认处理。原来被显式忽略的信号，其处理将不变。

*** 更改用户ID和组ID
所涉及的函数包括下面几个：
#+BEGIN_SRC c
#include <unistd.h>
int setuid(uid_t uid);
int setgid(gid_t gid);
//r for real,e for effective
int setreuid(uid_t ruid,uid_t euid);
int setregid(gid_t rgid,gid_t egid);
int seteuid(uid_t uid);
int setegid(gid_t gid);
#+END_SRC

设置用户ID(set-user-id)是否启用，可通过_SC_SAVED_IDS选项检查。若可执行文件的设置
用户ID位打开，则该文件的执行进程的euid将被设置为文件的所有者ID。

进程的保存设置用户ID(saved_id)在exec时，被设置为euid.

对于setuid(uid)行为是这样的：
- 如果是超级用户进程的话，那么ruid=uid,euid=uid,saved_id=uid.
- 如果不是超级用户进程的话，如果uid==ruid或者saved_id，那么euid=uid.
- 出错那么返回-1并且errno=EPERM.

seteuid(uid)，同样地，对于非特权用户，只能将euid设置为ruid或saved_id。

gid的设置规则，与此类同。

*** 解释器文件
解释器文件是以#!开头的文件，格式是

#+BEGIN_EXAMPLE :file X
#!pathname [optional-arguments]
#+END_EXAMPLE

假设文件是X,我们正准备执行./X arg0 arg1.那么exec会做如下处理：
- 识别出是解释器文件X
- 直接调用pathname [optional-arguments] X arg0 arg1

#+BEGIN_SRC c
#include <stdio.h>
int main(int argc,char* const argv[]){
    for(int i=0;i<argc;i++){
        printf("%s\n",argv[i]);
    }
    return 0;
}
#+END_SRC

#+BEGIN_EXAMPLE :file interpreter
#!./main hello world
#+END_EXAMPLE

#+BEGIN_SRC sh
[dirlt@localhost.localdomain]$ ./interpreter arg0 arg1
./main
hello world
./shell
arg0
arg1
#+END_SRC

好处是隐藏内部细节，如果文件是python编写的话，执行起来并没有调用python。
其次和效率相关。

*** system函数
system函数使用起来非常方便，但是需要了解其中细节才可能用好。system本身实现大致就是
- fork/exec
- 使用命令/bin/sh -c来执行cmdstring
- 父进程使用waitpid得到结果

对于system的返回值有下面三种：
- 如果fork或者是waitpid返回除EINTR之外的错误，那么返回-1并且设置errno
- 如果exec失败的话，那么/bin/sh返回值相当执行exit(127).
- 如果都成功的话，那么返回命令的终止状态。

因为cmdstring是通过/bin/sh来执行的，故允许里面包含glob符号和重定向等shell字符。

若某执行文件设置了设置用户ID(set-user-id)或者设置组ID(set-group-id)，则某进程
在执行它时，该进程的euid或者egid将被设置为执行文件的所有者ID或文件的组ID，这个euid
或者egid将被该执行文件中fork的子进程继承，这样，这个新的子进程exec另一个可执行文件
时，进行的权限检查将是围绕第一个执行文件的所有者ID或者第一个可执行文件的组ID，为
避免发生这种情况，在fork之后，exec之前，应该将进程的euid设置为进程的ruid。某些系统
上的system函数在内部实现就是这么做的。建议，不要在设置了设置用户ID或设置了设置组ID
的可执行文件内部调用system函数。

*** 进程调度

#+BEGIN_SRC c
int nice(int incr);//incr增加到调用进程的nice值上。incr越大，越nice,进程优先级越低

/*which could be PRIO_PROCESS, PRIO_PGRP, PRIO_USER, which means who is 
  a process id, a process group id or a user id respectively. */
int setpriority(int which, id_t who, int value); 
int getpriority(int which, id_t who);
#+END_SRC

未谈及调度策略。

为谈及CPU亲和性。

*** 进程时间
[[%E8%BF%9B%E7%A8%8B%E6%97%B6%E9%97%B4][请参阅前面一节]]

** 进程关系
*** 登录过程
首先看看终端登录过程，这个过程是BSD的，但是Linux基本相同：
- 管理员创建/etc/ttys文件，每个终端设备有一行表明设备名和getty启动参数。
- 系统自举创建init进程，init进程读取/etc/ttys文件，对每个终端fork并且exec gettty.
- getty打开终端设备，这样就映射到了文件描述符0,1,2.然后初始化环境，exec login.
- login基本功能就是读取用户密码，然后验证。如果失败的话，那么直接退出。
- 失败的话，那么init会接收到失败的信号，然后重新fork一个getty出来。

如果login成功的话，那么会执行下面这些动作：
- 更改目录为当前用户home目录
- chown终端权限所有权，使登录用户为所有者
- 将终端设备访问权限修改称为用户读写
- 调用setgid和initgroups设置进程的组id
- 设置环境变量，然后exec shell

bash启动之后会读取.bash_profile.这样用户最终的话，通过终端连接到终端设备驱动程序，
而终端设备的读写被映射成为0,1,2文件描述符被shell使用。用户操作终端的话，会被终端
设备驱动程序接收到，而对于shell来说，这些操作就是直接从0,1,2读取和写入数据。对于
Linux来说，唯一不同的就是，对于gettty启动过程参数不是在文件/etc/ttys而是在
/etc/inittab里面描述的。

网络登录。init进程启动inted进程，inted监听某些登录端口，比如
telnet登录，inetd会监听23端口。这样，当用户请求到达的话，会启动一个telnetd服务，
好比getty,只不过telnetd连接的是一个伪终端设备驱动程序，但是文件描述符依然是
0,1,2，但是telnetd并不会直接exec login.因为如果login执行失败的话，那么没有办法重新
启动telnetd(注意现在login失败的话，那么父进程是init而不是telnetd).所以telnetd通过
fork一次，用子进程exec login.如果子进程失败的话，那么父进程可以感知到。如果成功的
话，那么和终端登录一样。

*** 进程组
进程组通常和一个作业相关联，可以接受来自同一终端的各种信号。每个进程组有一个唯一
的进程组ID，也有一个组长进程，组长进程的进程id等于进程组的id。
#+BEGIN_SRC c
pid_t getpgrp();  // 返回调用进程的进程组ID
pid_t getpgid(pid_t pid); //如果pid==0,那么就是调用进程进程组id
#+END_SRC
进程组的生命周期是最后一个进程消亡或者是离开了该进程组，与进程组长是否终止没有关系。
进程组组长终止，也不改变该进程组的ID，但这样使得该进程组中没有任何进程的进程ID等于
该进程组的ID，那这个进程组就没有组长进程了。

也可以使用
#+BEGIN_SRC c
int setpgid(pid_t pid,pid_t pgid);
#+END_SRC
将pid的进程组id设置为pgid，但pid与pgid应在同一个会话。
pid==0的话，那么使用调用进程的pid。如果pgid==0的话，那么将pid设置为pgid.

进程只能为它自己及其子进程设置进程组ID，且在子进程调用了exec之后，父进程就不能再
更改子进程的进程组ID了。

鉴于父、子进程执行的先后顺序是不确定的，为了给子进程设置进程组ID，应该在fork之后的
父、子进程中分别为子进程设置一次子进程的进程组ID，即使这其中有一次是多余（出错返回）。
但这保证了父、子进程在认为子进程已进入了该进程组之前，子进程的确已进入了该进程组。

*** 会话
会话是一个或者是多个进程组的集合。会话中的进程所在的进程组也属于该会话。

#+BEGIN_SRC c
pid_t setsid();
pid_t getsid(pid_t pid);
#+END_SRC

当调用进程不是一个进程组的组长时，setsid建立一个新会话，否则，出错返回。
新会话创建后，
- 调用进程成为新会话首进程(session leader).
- 调用进程成为新进程组组长.
- 调用进程断开与控制终端的联系。

为保证调用进程不是一个进程组的组长，通常，先调用fork，再终止父进程，因子进程继承了
父进程的进程组ID，所以，子进程的进程ID就不等于其进程组ID。

调用getsid可以获得会话首进程的进程组ID,也就是会话首进程进程id.

*** 孤儿进程组
如果某进程组中存在一个进程，该进程的父进程在同一会话的另一个进程组，则该进程组就
不是孤儿进程组。

如果某个进程终止，使得某个进程组成为了孤儿进程组，则系统会向该孤儿进程组里面的
每个处于停止状态的进程发送SIGHUP信号，然后再发送SIGCONT信号。这里需要注意，处于
停止状态的进程，对于收到的除SIGKILL和SIGCONT之外的任何信号的处理，都发生在该进程
收到并处理了SIGCONT（该信号可以被捕捉）之后。
*** 控制终端与作业控制
一个会话有一个终端（或伪终端）。一个会话有多个进程组，从终端的角度讲，这些进程组
中，可以有一个是前台进程组，其余的是后台进程组。只有前台进程组可以访问终端。

设置或获取前台进程组的系统调用如下。参数fd必须引用的是控制终端，如果没有重定向，
一般标准输入、标准输出、标准出错都引用着控制终端。如果执行本节以下示例时，指定了
输入定向，则代码中通过标准输入查询前台进程组时，会发生错误。

#+BEGIN_SRC c
pid_t tcgetpgrp(int fd);
int tcsetpgrp(int fd,pid_t pgrpid);
pid_t tcgetsid(int fd);
#+END_SRC

作业控制就是控制进程组对终端的访问。
作业控制需要有支持作业的shell、支持作业的终端驱动、内核提供的作业控制信号。
作业控制相关的信号如下，
- SIGTSTP(Ctrl+Z)
  终端驱动发送给前台进程组的每个进程。
- SIGINT(Ctrl+C)
  终端驱动发送给前台进程组的每个进程。
- SIGQUIT(Ctrl+\)
  终端驱动发送给前台进程组的每个进程。产生core文件。
- SIGHUP
  - 远程连接（CLOCAL未设置）的终端检查到连接断开时，发给与终端相关的会话首进程。
    会话首进程可能处于后台。
  - 会话首进程终止时，发给前台进程组中每个进程。  
- SIGCONT(fg命令)
  - 对暂停的进程，默认是恢复运行，其他的进程，默认是忽略。可以被捕捉。
  - 处于暂停状态的进程，可以被该信号唤醒，也能被SIGKILL杀死，但其他信号都将被挂起。
- SIGTTIN
  - 产生条件
    - 该后台进程没有忽略或者阻塞该信号。
    - 该进程所属的进程组非孤儿进程组。
    - 后台进程尝试读取控制终端时, 该信号由控制终端的驱动发给该后台进程。
  - 后台进程在收到该信号后，将暂停执行。
- SIGTTOUT
  - 产生条件
    - 该后台进程没有忽略或者阻塞该信号。
    - 该进程所属的进程组非孤儿进程组。
    - 该后台进程尝试写控制终端时，该信号由控制终端的驱动发给该后台进程。
  - 不同于SIGTTIN，一个进程可以选择允许后台进程写控制终端。
  - 后台进程在收到该信号后，将暂停执行。
  
#+BEGIN_SRC c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void handler(int signo) {
  printf("SIGTTIN received by %d, a background process\n", getpid());
  signal(SIGTTIN, SIG_DFL);
}

int main(int argc, char *argv[]) {
  pid_t ppid;
  char c;

  signal(SIGTTIN, handler);

  printf("self: pid=%d, pgrp=%d, tpgrp=%d\n",
         getpid(), getpgrp(), tcgetpgrp(STDIN_FILENO));
  ppid = getppid();
  printf("parent: pid=%d, pgrp=%d, tpgrp=%d\n",
         ppid, getpgid(ppid), tcgetpgrp(STDIN_FILENO));
  read(STDIN_FILENO, &c, 1); // self is foreground, so it can read from stdin

  tcsetpgrp(STDIN_FILENO, ppid);
  printf("tpgrp=%d\n", tcgetpgrp(STDIN_FILENO));
  read(STDIN_FILENO, &c, 1); // self is background, so it is stopped by SIGTTIN

  return 0;
}
#+END_SRC
*** 案例
进程组组长终止后，进程组ID没变。

进程组组长终止后，子进程成为了进程组中唯一的进程，且子进程的父进程所在的进程组与
子进程自己所在的进程组不在同一个会话，所以，该进程组成为了孤儿进程组。

进程组组长终止时，子进程由于收到了自举的SIGTSTP信号而处于停止状态，且该组长的终止，
使得该进程组成为了孤儿进程组，故在组长终止时，内核想该子进程相继发送了SIGHUP和SIGCONT。

#+BEGIN_SRC c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <signal.h>

void sig_handler(int signo) {
  printf("signo %d reveived by pid %d\n", signo, getpid());
}

int main(int argc, char *argv[]) {
  pid_t cpid;

  if((cpid = fork()) == -1) {
    perror("Error when fork()");
    exit(1);
  }
  if(cpid == 0) {
    pid_t pid, pgrp, sid, ppid, ppgrp, psid;
    signal(SIGHUP, sig_handler);
    signal(SIGCONT, sig_handler);
    raise(SIGTSTP);  //sleep(5);
    pid = getpid(); pgrp = getpgrp(); sid = getsid(0);
    ppid = getppid(); ppgrp = getpgid(ppid); psid = getsid(ppid);
    printf("\nChild: pid=%d; ppid=%d; pgrp=%d; sid=%d, tpgrp=%d\n",
           pid, ppid, pgrp, sid, tcgetpgrp(STDIN_FILENO));
    printf("Parent of Child: pid=%d; pgrp=%d; sid=%d, tpgrp=%d\n",
           ppid, ppgrp, psid, tcgetpgrp(STDIN_FILENO));

    if((pgrp!=ppgrp) && (sid==psid)){
      printf("pgrp %d is not an orphan\n", pgrp);
    }
    else
      printf("pgrp %d is an orphan\n", pgrp);

    exit(0);
  }
  else if(cpid > 0){
    sleep(2);
    printf("Parent: pid=%d; ppid=%d; pgid=%d, sid=%d, tpgrp=%d\n",
           getpid(), getppid(), getpgrp(), getsid(0), tcgetpgrp(STDIN_FILENO));
    exit(0);
  }
}
#+END_SRC

** 信号处理
*** 常见信号
没有数值为0的信号。

- SIGKILL
  - 既不能被不捕捉，也不能被忽略。
- SIGTERM 
  - 用于终止进程，由于其可被捕获，从而有机会做清理工作。
- SIGSTOP
  - 既不能被不捕捉，也不能被忽略。
- SIGALRM   
  - alarm函数或setitimer函数设置的定时器超时时，产生此信号。
  - 默认动作是进程终止。
- SIGPIPE
  - 写一个读进程已终止的管道时，产生。
  - 写一个不再连接的SOCK_STREAM套接字时，产生。
- SIGIO
  - 异步IO
  - 默认终止进程
- SIGURG
  通知进程发生了紧急情况。在网络连接上接到带外数据时，可选择产生此信号。
- SIGABRT   
  - abort函数产生磁信号。
  - 默认动作是进程异常终止，产生core文件。
- SIGUSR1 SIGUSR2
  用户自定义。

*** 不可靠的信号处理
signal函数提供旧的不可靠信号语义，它的存在是为了兼容性，同时，它在多线程应用中
的行为是不确定的，不具有可移植性。在新的应用中，当捕捉信号时，应使用sigaction函
数代替signal；当修改为SIG_IGN或SIG_DFL时，可以调用signal，这样做也有可移植性。

早期的版本中，每当一个信号被处理时，系统都会自动将该信号的处理重置为默认，为避免，
就需要在信号处理中再次调用signal，既使这样，在捕捉到该信号之后到在信号处理中调用
signal之前的这个窗口内收到的该信号还是会被按默认的处理，从而，可能终止进程，也可能
丢失该信号。不过，经测试，在新的Linux内核中，应该是使用了类似于BSD的方案，该方案不
会将经由signal捕捉的信号的处理重置为默认，该方案将自动重启可以被自动重启的、当前
被信号处理中断的系统调用。

其次对于信号控制能力差，只是提供捕捉和忽略，如果想先阻塞某信号，待到进程做好准备
时，再去处理该信号，是办不到的。
#+BEGIN_SRC c
int flag;
void sig_handler(int signo){
    flag=1;
}

int main(){
    signal(SIGUSR1,sig_handler);
    flag=0;
    // 以下逻辑只需调用 sigsuspend(sigmask)即可被原子性地实现
    //我们这里想仅当触发了SIGUSR1才退出
    while(flag==0){
        //若唯一的SIGUSR1发生在这个窗口内，则该进程会睡眠在pause()
        pause();
    }
    return 0;
}
#+END_SRC

*** 中断的系统调用
对于被中断的系统调用，有两种处理方法，自动重启，或者，出错EINTR返回。Linux中，所有
的系统调用都是采取的出错EINTR返回，同时，还对部分系统调用提供了自动重启的功能，
要想使用该功能，需要通过标志SA_RESTART调用sigaction函数，详情参考 signal(7) 。

使用SA_RESTART，有时候，也会产生一些问题，如下例, 如果在read时，发生了SIGINT，则信
号处理程序结束后，被中断的read将会被自动重启，从而，再次等待输入一个字符。
#+BEGIN_SRC c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

volatile int signaled = 0;
void handler(int signo) {
  signaled = 1;
}

int main() {
  char ch;
  struct sigaction sigact;
  
  sigact.sa_handler = handler;
  sigact.sa_flags = SA_RESTART;
  sigaction(SIGINT, &sigact, NULL);

  while(read(STDIN_FILENO, &ch, 1)!=1 && !signaled);
}
#+END_SRC

综上，尽量少使用SA_RESTART，这样，既不需区分某系统调用是否可自动重启，也避免了上例
的问题。
*** 可重入函数
假设我们正在执行函数A,而正在这个时候出发了信号处理函数，里面也调用了A.我们必须确保
两次调用A的结果都完全正确。如果保证调用完全正确的话，那么这个函数就是可重入函数。
很明显可重入函数，对应着就是没有使用全局变量的函数。

异步信号安全，也称信号安全，指某函数被信号中断后，该函数还可在相应的信号处理函数中
安全调用。

可重入函数和线程安全函数的区别。可重入既要求是线程安全的，又要求信号安全。 如果某个
函数使用了全局变量，但是，通过加锁等方式确保了对该全局变量的访问是串行进行的，那么
这个函数就是线程安全函数。通过加锁的方式是没法保证可重入的，而是需要去掉全局变量、
静态变量等。malloc/free是线程安全的，而非可重入的。

*** 可靠信号
我们首先看看可靠信号下面存在哪些术语：
- 信号的产生(generation).
  信号的产生可能是由于硬件异常、alarm定时器超时、终端产生或kill函数等。
- 信号的递送(delivery).
  当信号处理函数被调用时，那么就说向进程递送了这个信号。
- 未决(pending)的信号.
  在信号产生和信号被递送的这段时间，信号是未决的。
- 阻塞(blocking).
  某信号被进程屏蔽（sigprocmask），且其处理方式不是忽略的话，那么该信号会一直保持
  未决(pending)状态，直到取消对该信号的屏蔽，或处理方式改为忽略。
  信号在递送时，才决定该信号的处理方式，所以，可在未决的信号被解除阻塞之前，更改
  其处理方式。
- 排队(queue).
  阻塞时候如果对应信号发生多次的话，那么信号会累加。
  不过Linux并不排队，而只是保存一次。
- 递送顺序(delivery order).
  系统并没有规定如果多个信号发生，那么哪个信号会首先被递送。
  但是通常来说是关系到当前进程状态信号被处理，比如SIGSEGV.
- 信号屏蔽字(signal mask).
  当前要阻塞送到该进程的信号集。

*** 信号集
#+BEGIN_SRC c
//sigset_t as the set of signals
int sigemptyset(sigset_t* set); //清空
int sigfillset(sigset_t* set); //填充
int sigaddset(sigset_t* set,int signo) //添加信号
int sigdelset(sigset_t* set,int signo) //删除信号
int sigismember(const sigset_t* set,int signo) //检查是否存在
#+END_SRC
**** sigprocmask/sigpending
sigprocmask可以增加、解除、设置、获取当前信号屏蔽字。该调用是仅为单线程进程定义的。
sigpending可以返回当前未决信号集。

#+BEGIN_SRC c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>

void sig_handler(int signo){
}
int main(){
    sigset_t set;
    sigemptyset(&set);
    sigaddset(&set,SIGUSR1);
    sigaddset(&set,SIGUSR2);
    signal(SIGHUP,sig_handler);
    sigprocmask(SIG_BLOCK,&set,NULL);
    /* sleep until a signal delivered that terminates the process 
       or invokes a signal-catching function. */
    pause(); 
    sigpending(&set);
    printf("pending SIGUSR1=%d\n",sigismember(&set,SIGUSR1));
    printf("pending SIGUSR2=%d\n",sigismember(&set,SIGUSR2));
}
#+END_SRC

**** sigaction

#+BEGIN_SRC c
// <signal.h> 
struct sigaction {
  union { //Notice, sa_handler and sa_sigaction share one pointer variable. 
    __sighandler_t _sa_handler;
    void (*_sa_sigaction)(int, struct siginfo *, void *);
  } _u;
  sigset_t sa_mask;
  unsigned long sa_flags;
  void (*sa_restorer)(void);
};
#define sa_handler  _u._sa_handler
#define sa_sigaction  _u._sa_sigaction

int sigaction(int signo,const struct sigaction* restrict act,struct sigaction* restrict oact);
#+END_SRC

通常，还是使用sa_handler来处理信号。sa_flags(默认为0)包含的选项有：
- SA_INTERRUPT
  信号中断的系统调用不会自动重启
- SA_RESTART 
  信号中断的系统调用会自动重启 
- SA_SIGINFO    
  使用sa_sigaction而不是sa_handler来处理，但有些系统，如Linux，它们是同一个函数
  地址，只不过当作不同函数处理时，传入的参数不同。
- SA_ONSTACK 
  捕捉到信号时，会将信号传递到使用了signalstack替换栈上的进程 
- SA_RESETHAND  
  在此信号捕捉函数的入口处，将信号处理重置为SIG_DFL
- SA_NODEFER
  在执行信号处理函数时，并不屏蔽这个信号
- SA_NOCLDSTOP 
  #<<SA_NOCLDSTOP>>
  只对SIGCHLD信号有效。
  子进程停止/恢复/终止时，父进程会收到SIGCHLD（默认忽略），但如果父进程设置了
  SA_NOCLDSTOP，则只有当子进程终止时，父进程才会收到SIGCHLD，停止/恢复时不会。
  不影响wait/waitpid的返回。
  #+BEGIN_SRC c
  #include <sys/wait.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <stdio.h>
  #include <sys/ptrace.h>
  
  void sighandler(int signo) {
    printf("signal %d is received\n", signo);
  }
  
  int main(int argc, char *argv[]) {
    pid_t cpid, w;
    int status;
    struct sigaction act, oact;
  
    cpid = fork();
    if (cpid == -1) {
      perror("fork");
      exit(EXIT_FAILURE);
    }
    if (cpid == 0) {            /* Code executed by child */
      printf("Child PID is %ld\n", (long) getpid());
      if (argc == 1)
        pause();                    /* Wait for signals */
      _exit(atoi(argv[1]));
    } else {                    /* Code executed by parent */
      sigemptyset(&act.sa_mask);
      act.sa_handler = sighandler;
      act.sa_flags = 0; //SA_NOCLDSTOP;
      sigaction(SIGCHLD, &act, &oact);
      do {
        w = waitpid(cpid, &status, 0); //WCONTINUED | WUNTRACED);
        if (w == -1) {
          perror("waitpid");
          exit(EXIT_FAILURE);
        }
        if (WIFEXITED(status)) {
          printf("exited, status=%d\n", WEXITSTATUS(status));
        } else if (WIFSIGNALED(status)) {
          printf("killed by signal %d\n", WTERMSIG(status));
        } else if (WIFSTOPPED(status)) {
          printf("stopped by signal %d\n", WSTOPSIG(status));
        } else if (WIFCONTINUED(status)) {
          printf("continued\n");
        }
      } while (!WIFEXITED(status) && !WIFSIGNALED(status));
      exit(EXIT_SUCCESS);
    }
  }
  #+END_SRC
- SA_NOCLDWAIIT 
  #<<SA_NOCLDWAIT>>
  只对SIGCHLD信号有效。
  父进程的sigaction设置了该选项后，子进程终止时，不会创建僵死进程，是否会发
  SIGCHLD具体看系统（Linux会）。
  在Linux中，综合SA_NOCLDWAIT与SA_SIGINFO，对SIGCHLD捕获，可以获得子进程终止的详细
  信息，但是，由于信号不排队，当多个子进程同时终止时，只能获得一个子进程的终止信息。
  #+BEGIN_SRC c
  void sig_action(int signo, siginfo_t *info, void* ctxt) {
    printf("SIGCHLD: si_code=%d, si_pid=%d, si_uid=%d, si_status=%d\n",
           info->si_code, info->si_pid,
           info->si_uid, info->si_status);
  }

  int main(int argc, char *argv[]) {
    pid_t cpid;
    struct sigaction act;
  
    sigemptyset(&act.sa_mask);
    act.sa_sigaction = sig_action;
    act.sa_flags =  SA_NOCLDWAIT|SA_SIGINFO;
    sigaction(SIGCHLD, &act, NULL);
  
    for(int i=0; i<100; i++) {
      cpid = fork();
      if(cpid==0) {
        break;
      }
    }
  
    if(cpid>0) {
      printf("Press q to exit ...");
      while('q'!=getchar());
    }
    return 0;
  }
  #+END_SRC
**** sigsetjmp/siglongjmp
#<<sigsetjmp>>

#+BEGIN_SRC c
int sigsetjmp(sigjmp_buf env, int savemask); //是否保存信号屏蔽字
int siglongjmp(sigjmp_buf env, int val); 
#+END_SRC

参数savemask非0，指示在env中保存进程的当前信号屏蔽字。参数val，表示调用siglongjmp
跳转后，sigsetjmp的返回值，注意，第一次调用sigsetjmp使的返回值是0。

对于setjmp和longjmp并没有规定如何来处理信号屏蔽字，参见[[非局部跳转][非局部跳转]]。

#+BEGIN_SRC c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <setjmp.h>

sigjmp_buf env; //jmp_buf env;

void handler(int signo) {
  siglongjmp(env, 1); //longjmp(env, 1);
}

int main() {
  if(sigsetjmp(env, 1) ==1 ) { // if(setjmp(env) == 1) {
    sigset_t mask;
    sigprocmask(SIG_BLOCK, NULL, &mask);
    printf("SIGUSR1 masked=%d\n", sigismember(&mask, SIGUSR1));
    exit(0);
  }
  signal(SIGUSR1, handler);
  pause();
  return 0;
}
#+END_SRC

**** sigsuspend
#<<sigsuspend>>

#+BEGIN_SRC c
int sigsuspend(const sigset_t* sigmask);
#+END_SRC
该函数原子性地实现了
- 将进程的信号屏蔽字设置为sigmask
- 进程挂起直到捕捉到一个未被屏蔽的信号，或者收到会终止该进程的信号
- 该函数返回时，自动恢复调用之前的信号屏蔽字。

该函数适用于，挂起进程直到收到某个信号。
*** 常用函数
**** kill/raise
#+BEGIN_SRC c
#include <signal.h>
//1.pid>0
//2.pid==0 发送给属于同一进程组进程，但是不包括系统进程
//3.pid<0 发送给进程组id==abs(pid)进程，但是不包括系统进程
//4.pid==-1 发送给所有有发送权限的所有进程
int kill(pid_t pid,int signo);
int raise(int signo); //==kill(getpid(),signo)
#+END_SRC
权限检查是，发送者进程有特权(CAP_KILL)，或者，发送者进程的实际用户ID或有效用户ID
等于接收者进程的实际用户ID或保存的设置用户ID。
如果信号是SIGCONT，可以被发送给同一个会话里面所有进程。

**** alarm/pause
#+BEGIN_SRC c
#include <unistd.h>
unsigned int alarm(unsigned int secs);
int pause();
#+END_SRC
alarm设置闹钟。每个进程只可设置一个闹钟。闹钟时间到时，进程会收到SIGALM信号（默认
终止进程）。新设置的闹钟覆盖之前设置但还没超时的闹钟，且设置新闹钟调用的alarm的
返回值是之前设置的闹钟的剩余时间。如果传入参数为0，用于取消设置的闹钟。

当从一个执行的信号处理程序返回时，pause才返回，返回值-1，errno为EINTR.
**** abort
此函数向进程自身发送SIGABRT信号以终止进程的执行，即使该信号的处理方法被设置为
忽略或者捕获。

这时进程可以捕获该信号，通过信号处理程序执行一些清理工作。当从信号的处理程序
返回时，同样会导致进程的终止。要想避免终止进程，可在信号处理程序返回前调用
longjmp或者siglongjmp。

如果abort导致了进程的终止，则所有打开标准IO流将会被冲洗和关闭。
**** system
#+BEGIN_SRC c :file app.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

void sig_int(int signo) {
  printf("SIGINT caught by child\n");
}

int main(){
  signal(SIGINT, sig_int);

  printf("pgrp of pid %d: %d, pgrp of ppid %d: %d\n",
         getpid(), getpgrp(), getppid(), getpgid(getppid()));

  while(1);
  return 0;
}
#+END_SRC

#+BEGIN_SRC c :file mysystem.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>
#include <string.h>

void sig_int(int signo) {
  printf("SIGINT caught by parent\n");
}

void sig_chld(int signo, siginfo_t * info, void *ctxt) {
  int status;

  printf("SIGCHLD: si_code=%d, si_pid=%d, si_uid=%d, si_status=%d\n",
         info->si_code, info->si_pid,
         info->si_uid, info->si_status);
  status = info->si_status;
  if (WIFEXITED(status)) {
    printf("exited, status=%d\n", WEXITSTATUS(status));
  } else if (WIFSIGNALED(status)) {
    printf("killed by signal %s\n", strsignal(WTERMSIG(status)));
  } else if (WIFSTOPPED(status)) {
    printf("stopped by signal %s\n", strsignal(WSTOPSIG(status)));
  } else if (WIFCONTINUED(status)) {
    printf("continued\n");
  }

  while(waitpid(-1, &status, 0)>0){
    printf("waitpid()\n");
  }
}
int main(){
  int status;
  struct sigaction act, oact;
  sigemptyset(&act.sa_mask);
  act.sa_sigaction = sig_chld;
  act.sa_flags = SA_SIGINFO;
  sigaction(SIGCHLD, &act, &oact);

  signal(SIGINT, sig_int);

  printf("pid: %d, ppid: %d, pgrp: %d\n",  getpid(), getppid(), getpgrp());
  printf("tcpgrp for 0 and 1 respentively: %d %d\n", tcgetpgrp(0), tcgetpgrp(1));
  status = system("./a.out");
  printf("return from system(): %d", status);
 
  while(1);
  return 0;
}
#+END_SRC

#+BEGIN_EXAMPLE
ubuntu@ip-172-31-26-73:~/APUE$ gcc app.c
ubuntu@ip-172-31-26-73:~/APUE$ gcc mysystem.c -o mysystem
ubuntu@ip-172-31-26-73:~/APUE$ ./mysystem
pid: 3391, ppid: 865, pgrp: 3391                               // 1)
tcpgrp for 0 and 1 respentively: 3391 3391
pgrp of pid 3393: 3391, pgrp of ppid 3392: 3391
^CSIGINT caught by child                                       // 2)
^\SIGCHLD: si_code=3, si_pid=3392, si_uid=1000, si_status=3    // 3)
killed by signal Quit
return from system(): 131
^CSIGINT caught by parent                                      // 4)
^\Quit (core dumped)
#+END_EXAMPLE

1) a.out运行pid是3393，system启动/bin/sh的运行pid是3392，mysystem运行pid是3391，
  他们都属于前台进程组3391。

2) SIGINT(Ctrl+C)和SIGQUIT(Ctrl+\)会被发给前台进程组的所有进程，但这里注意到，只有
   3393捕获了SIGINT，原因是,system调用开始时会自动将SIGINT和SIGQUIT设置为忽略处理，
   目的是，SIGINT和SIGQUIT不会导致3391终止。
   另外，system调用开始时，也阻塞了SIGCHLD。

3) SIGQUIT(Ctrl+\)（只）导致了3393终止，发出了SIGCHLD信号到3392，3392应该是捕获了
   该信号，获取到3393的终止状态，并将该状态作为3392的终止状态。
   3392终止时，发出的SIGCHLD信号被3391阻塞了，如2)所言。原因是，system函数中调用了
   wait等着3392结束，进而获取到3393的终止值，并作为system函数的返回值，若不阻塞，
   则3391中SIGCHLD的信号处理程序会先于system函数中的wait执行，这会使得信号处理程序
   中调用的waitpid最终释放3392，从而system函数中的wait出错返回，得不到3392的终止
   状态。也因此，可以看到system函数返回的值等于SIGCHLD处理程序中打印的si_stauts，
   同时，看到SIGCHLD处理程序中waitpid并没有获取到3392的信息。
   在system函数中的wait执行后，system函数返回前，解除了SIGCHLD的阻塞，使得3391
   中SIGCHLD的信号处理程序得以执行。

4) 3392终止前，也恢复了3391对信号SIGINT和SIGQUIT的处理。 
**** sleep/nanosleep
#+BEGIN_SRC c
unsigned int sleep(unsigned int seconds);
#+END_SRC
挂起进程直到seconds秒超时，或者捕捉到一个信号且从信号处理程序返回，返回值是
剩余的时间。注意，该函数可能通过alarm函数实现，所以，为了可移植性，不应混合调用
sleep和alarm。

#+BEGIN_SRC c
struct timespec {
  time_t tv_sec;
  long   tv_nsec;
};
int nanosleep(const struct timespec *reqtp, struct timespec *remtp);
#+END_SRC 
挂起进程直到reqtp超时，或者捕捉到一个信号且从信号处理程序返回。属于后者的话，返回
值是-1，并相应设置errno，剩余的时间存在remtp中。不同于sleep(3)及usleep(3)，该函数
的实现与信号(SIGALRM)无关。

**** 其他函数
和errno对应的strerror以及perror一样，对于信号也提供了相应的方便打印的函数：
#+BEGIN_SRC C++
#include <signal.h>
void psignal(int signo,const char* msg);
const char* strsignal(int signo);
#+END_SRC

** 线程控制
对于线程来说，包含了表示进程内执行环境所必须的信息，其中包括：
- 线程ID
- 寄存器堆
- 栈
- 调度优先级和策略
- 信号屏蔽字
- errno
- 线程私有数据
共享的进程资源主要包括：
- text段
- 数据段，堆，栈
- 文件描述符
我们使用的是POSIX.1-2001定义的线程接口，pthread or POSIX线程。可以使用_POSIX_THREADS/
_SC_THREADS来测试是否支持POSIX线程。

pthread函数在调用失败的时候通常会返回错误码，它们并不像其他的POSIX函数一样设置全局errno。同时每个线程
拥有一个线程局部的errno副本，这样可以和使用了errno的现有函数兼容。

*** 线程限制
线程限制有下面这些方面：
| 限制名称                      | 描述                                               |
|-------------------------------+----------------------------------------------------|
| PTHREAD_DESTRUCTOR_ITERATIONS | 线程退出操作系统实现试图销毁线程似有数据的最大次数 |
| PTHREAD_KEYS_MAX              | 进程可以创建的键最大个数                           |
| PTHREAD_STACK_MIN             | 一个线程可用栈的最小字节数                         |
| PTHREAD_THREADS_MAX           | 进程可以创建最大线程数                             |
关于第一个参数后面可以看到为什引入的。键使用来定位线程私有数据的。每个线程都是在特定的可用栈上进行的。

*** 线程标识
线程使用线程id来标识自己，thread_t这个数据结构。我们不能够使用一种可移植的方式来打印该数据类型的值。
#+BEGIN_SRC c
pthread_t pthread_self(); //获得自身的线程标识
int pthread_equal(pthread_t tid1,pthread_t tid2); //比较两个线程号是否相同
#+END_SRC

但是这个pthread_t仅仅是一个逻辑的标识而不是系统标识，为了获得系统标识的话可以调用gettid这个函数。gettid是一个内核调用。
如果我们阅读pthread代码的话可以发现一种不通过系统调用得到tid的方法。

默认情况下面我们可以使用gettid这个系统调用得到thread id.但是我们可以通过汇编来得到thread id
而不调用系统调用。这个内容在fs寄存器指向的段144个字节上，占用4个字节。至于为什么是在144字节上的话，
可以阅读nptl/descr.h里面pthread结构体代码，每个线程的fs寄存器指向内容就是这个结构体。
#+BEGIN_SRC c
/* Thread descriptor data structure.  */
struct pthread
{
  union
  {
#if !TLS_DTV_AT_TP
    /* This overlaps the TCB as used for TLS without threads (see tls.h).  */
    tcbhead_t header;
#else
    struct
    {
      int multiple_threads;
    } header;
#endif

    /* This extra padding has no special purpose, and this structure layout
       is private and subject to change without affecting the official ABI.
       We just have it here in case it might be convenient for some
       implementation-specific instrumentation hack or suchlike.  */
    void *__padding[16];
  }; // 128字节

  /* This descriptor's link on the `stack_used' or `__stack_user' list.  */
  list_t list; // 2个指针，16个字节

  /* Thread ID - which is also a 'is this thread descriptor (and
     therefore stack) used' flag.  */
  pid_t tid; // 在这个地方

  /* Process ID - thread group ID in kernel speak.  */
  pid_t pid;

  // 省略后面字段
} __attribute ((aligned (TCB_ALIGNMENT)));
#+END_SRC

#+BEGIN_SRC c
#include <linux/unistd.h>
_syscall0(pid_t,gettid)

#include <unistd.h>
#include <sys/types.h>
#include <cstdio>

pid_t user_gettid(){
    pid_t pid=0;
    __asm__ __volatile__(
        "movl %%fs:%c1,%0\n\t"
        :"=r"(pid)
        :"i"(144));
    return pid;
}
int main(){
    printf("%d\n",user_gettid());
    printf("%d\n",gettid());
}
#+END_SRC

*** 线程属性
在创建线程的时候我们可以指定线程属性，接口是：

#+BEGIN_SRC c
int pthread_attr_init(pthread_attr_t* attr);
int pthread_attr_destroy(pthread_attr_t* attr);
#+END_SRC

线程属性包括下面这些：
- detachstate
  控制线程启动时候属性是分离的，还是可以join的。
  默认是joinable的，也可以随后使用pthread_detach来将这个线程属性修改成为分离状态。
  取值是PTHREAD_CREATE_DETACHED 或 PTHREAD_CREATE_JOINABLE 。
  #+BEGIN_SRC c
  int pthread_attr_getdetachstate(const pthread_attr_t* restrict attr,int* detachstate);
  int pthread_attr_setdetachstate(pthread_attr_t* attr,int detachstate);
  #+END_SRC
- stackaddr, stacksize, guardsize
  栈的最低地址、栈大小、栈警戒区（用于捕捉栈溢出）。
  #+BEGIN_SRC c
  int pthread_attr_getstack(const pthread_attr_t* restrict attr,void** restrict stackaddr,size_t* restrict stacksize);
  int pthread_attr_setstack(pthread_attr_t* addr,void* stackaddr,size_t stacksize);
  
  int pthread_attr_getstacksize(const pthread_attr_t* restrict attr,size_t* restrict stacksize);
  int pthread_attr_setstacksize(pthread_attr_t* attr,size_t stacksize);
  
  // guard 是用于捕捉栈溢出的
  int pthread_attr_getguardsize(const pthread_attr_t* restrict attr,size_t* restrict guardsize);
  int pthread_attr_setguardsize(pthread_attr_t* attr,size_t guardsize);
  #+END_SRC

*** 线程创建
创建接口为
#+BEGIN_SRC c
//1.tidp表示创建的线程号
//2.attr表示线程属性
//3.线程入口
//4.线程入口的参数
int pthread_create(pthread_t* restrict tidp,const pthread_attr_t* restrict attr,void* (*start)(void*),void* restrict arg);
#+END_SRC
线程创建并不保证那个线程会首先运行，是新创建的线程还是调用线程。新创建的线程可以访问进程的地址空间，
并且集成了线程的浮点环境和信号屏蔽字，但是对于未决的信号都会进行丢弃。

如果希望多个线程里面某些部分只是执行一次的话，可以使用下面这个接口：
#+BEGIN_SRC c
pthread_once_t initflag=PTHREAD_ONCE_INIT;
int pthread_once(pthread_once_t* initflag,void (*initfn)(void));
#+END_SRC
然后再每个线程里面调用pthread_once.下面是一个例子：
#+BEGIN_SRC c
#include <unistd.h>
#include <pthread.h>
#include <stdio.h>
#include <math.h>
#include <stdlib.h>

pthread_once_t initflag=PTHREAD_ONCE_INIT;
void run_once(){
    printf("just run once\n");
}
void* foo(void* arg){
    pthread_once(&initflag,run_once);
}
int main(){
    pthread_t tid[10];
    for(int i=0;i<10;i++){
        pthread_create(tid+i,NULL,foo,(void*)(long)i);
    }
    for(int i=0;i<10;i++){
        pthread_join(tid[i],NULL);
    }
    return 0;
}
#+END_SRC

*** 线程终止
如果进程中任意线程调用了_exit,Exit,exit的话，或者是任意线程接收到了信号而处理动作是终止的话，那么整个进程就会终止。
对于单个线程只有以下面三种方式退出的话，才可能在不终止整个进程情况下面停止它的控制流：
- 线程只是从启动例程中返回，返回值是线程的退出码。
- 线程可以被同一进程中的其他线程取消。
- 线程调用pthread_exit.
#+BEGIN_SRC c
void pthread_exit(void* ret_ptr); //返回ret_ptr
int pthread_join(pthread_t tid,void** ret_ptr); //得到ret_ptr内容
int pthread_cancel(pthread_t tid); //好比调用了pthread_exit(PTHREAD_CANCELED),只是通知线程而并不等待取消，是一个异步过程。
int pthread_detach(pthread_t tid);
#+END_SRC
对于pthread_join来说，直到指定的tid线程返回那么才返回。如果tid是取消的话，那么ret_ptr是PTHREAD_CANCELED.
pthread_join好比wait调用。如果线程是一个detach状态的话，那么pthread_join马上就会失败返回EINVAL.

和进程使用atexit一样，线程也允许存在这种清理函数：
#+BEGIN_SRC c
void pthread_cleanup_push(void (*func)(void*),void* arg);
void pthread_cleanup_pop(int execute); //非0表示立即执行,0表示不立即执行
#+END_SRC
通常来说这两个函数需要配对使用，因为很可能实现为宏。push包含{,而pop包含}.当线程返回的时候，那么就会触发push的函数：

#+BEGIN_SRC c
void foo(void* arg){
    printf("%s\n",(char*)arg);
}
void* pthread_func(void* arg){
    pthread_cleanup_push(foo,(void*)"push1");
    pthread_cleanup_push(foo,(void*)"push2");
    for(;;){
        sleep(5);
    }
    pthread_cleanup_pop(0);
    pthread_cleanup_pop(0);
    return NULL;
}

int main(){
    pthread_t tid;
    int ret=0;
    pthread_create(&tid,NULL,pthread_func,0);
    ret=pthread_detach(tid);
    if(ret){
        printf("pthread_detach:%s\n",strerror(ret));
    }
    ret=pthread_join(tid,NULL); //detach之后返回join返回EINVAL错误
    if(ret){
        printf("pthread_join:%s\n",strerror(ret));
    }
    pthread_cancel(tid);
    return 0;
}
#+END_SRC

#+BEGIN_EXAMPLE
[dirlt@localhost.localdomain]$ ./a.out
pthread_join:Invalid argument
push2
push1
#+END_EXAMPLE

*** 线程同步
关于线程同步，pthread提供了三种最基本的机制，分别是：
- 互斥锁
- 读写锁
- 条件变量
**** 互斥锁
互斥锁可以确保同一时间只有一个线程访问数据：
#+BEGIN_SRC c
//可以设置属性
int pthread_mutex_init(pthread_mutex_t* restrict mutex,const pthread_mutexattr_t* restrict attr);
int pthread_mutex_destroy(pthread_mutex_t* mutex);
#+END_SRC
对于互斥锁来说可以静态初始化为PTHREAD_MUTEX_INITIALIZER,也可以调用init来进行初始化。

互斥锁操作上有下面几种，包括加锁，解锁和尝试加锁(非阻塞行为):
#+BEGIN_SRC c
int pthread_mutex_lock(pthread_mutex_t* mutex);
int pthread_mutex_unlock(pthread_mutex_t* mutex);
int pthread_mutex_trylock(pthread_mutex_t* mutex);
#+END_SRC

**** 读写锁
对于部分应用来说是读多写少的应用，而读因为不会修改状态所以是允许读之间并发的。而互斥锁不管是读读之间，
还是读写之间都是会互斥的。读写锁就是用来解决这个问题的：
#+BEGIN_SRC c
//和互斥量不同的是，不允许静态初始化
int pthread_rwlock_init(pthread_rwlock_t* restrict rwlock,const pthread_rwlockattr_t* restrict attr);
int pthread_rwlock_destroy(pthread_rwlock_t* rwlock);
int pthread_rwlock_rdlock(pthread_rwlock_t* rwlock);
int pthread_rwlock_wrlock(pthread_rwlock_t* rwlock);
int pthread_rwlock_unlock(pthread_rwlock_t* rwlock);
int pthread_rwlock_tryrdlock(pthread_rwlock_t* rwlock);
int pthread_rwlock_trywrlock(pthread_rwlock_t* rwlock);
#+END_SRC
如果在同时有读写请求的话，优先权是交给系统来决定的。当然也有接口可以控制这个行为：
#+BEGIN_SRC c
/* Return current setting of reader/writer preference.  */
extern int pthread_rwlockattr_getkind_np (__const pthread_rwlockattr_t *
					  __restrict __attr,
					  int *__restrict __pref)
     __THROW __nonnull ((1, 2));

/* Set reader/write preference.  */
extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
					  int __pref) __THROW __nonnull ((1));
#+END_SRC

**** 条件变量
条件变量允许线程以一种更加友好的协作方式来运行。比如典型的生产和消费者模型来说，如果生产者停滞的话那么
消费者的动作就不断加锁解锁，通过轮训来检测状态会影响到协作性。相反如果生产者当只有生产出东西之后，
再来通知消费者的话，那么性能会更优：
#+BEGIN_SRC c
//如果生产者比消费者速度慢的话，那么大部分时间都在消费者的检查上
pthread_muext_t mutex;
void consumer(){
    pthread_mutex_lock(&mutex);
    if(has product){
        //consume something
    }
    pthread_mutex_unlock(&mutex);
}
void consumer(){
    pthread_mutex_lock(&mutex);
    //produce something
    pthread_mutex_unlock(&mutex);
}
#+END_SRC

#+BEGIN_SRC C++
//如果使用条件变量的话，那么大部分空间时间都会在cond_wait上等待，而系统就可以让出CPU
pthread_muext_t mutex;
pthread_cond_t cond;
void consumer(){
    pthread_mutex_lock(&mutex);
    pthread_cond_wait(&cond,&mutex);
    if(has product){
        //consume something
    }
    pthread_mutex_unlock(&mutex);
}
void consumer(){
    pthread_mutex_lock(&mutex);
    //produce something
    pthread_mutex_unlock(&mutex);
    pthread_cond_signal(&cond);
}
#+END_SRC
条件变量会首先判断条件是否满足，如果不满足的话那么会释放当前这个配对的锁，如果一旦触发的话那么会尝试加锁。

关于条件变量接口有下面这些：
#+BEGIN_SRC C++
int pthread_cond_wait(pthread_cond_t* restrict cond,pthread_condattr_t* restrict attr);
int pthread_cond_destroy(pthread_cond_t* cond)
int pthread_cond_wait(pthread_cond_t* restrict cond,pthread_mutex_t* restrict mutex);
//有超时时间控制的版本
int pthread_cond_timewait(pthread_cond_t* restrict cond,pthread_mutex_t* restrict mutex,const struct timespect* restrict timeout);
//只唤醒一个等待条件变量线程
int pthread_cond_signal(pthread_cond_t* cond);
//广播方式进行通知，唤醒所有等待这个条件变量线程
int pthread_cond_broadcast(pthread_cond_t* cond);
#+END_SRC
初始化也可以使用PTHREAD_COND_INITIALIZER来完成。
  
*** 同步属性
**** 进程共享
如果系统支持_POSIX_THREAD_PROCESS_SHARED选项，则可以通过将互斥锁、读写锁或条件变量
实现进程间的同步。方法是，在共享内存（如文件共享映射）上为同步变量分配内存，再将
同步变量的属性设置为PTHREAD_PROCESS_SHARED 。

#+BEGIN_SRC c
struct semaphore {
  pthread_mutex_t lock;
  pthread_cond_t nonzero;
  unsigned int count;
};
typedef struct semaphore semaphore_t;

semaphore_t * semaphore_create(char *name) {
  int fd;
  semaphore_t *semap;
  pthread_mutexattr_t psharedm;
  pthread_condattr_t psharedc;

  fd = open(name, O_RDWR|O_CREAT|C_EXCL, 0666);
  if(fd<0)
    return NULL;
  ftruncate(fd, sizeof(semaphore_t));
  semap = (semaphore_t *) mmap(NULL, sizeof(semaphore_t), PROT_READ|PROT_WRITE,
          MAP_SHARED, fd, 0);
  close(fd);

  pthread_mutexattr_init(&psharedm);
  pthread_mutexattr_setpshared(&psharedm, PTHREAD_PROCESS_SHARED);
  pthread_condattr_init(&psharedc);
  pthread_condattr_setpshared(&psharedc, PTHREAD_PROCESS_SHARED);

  pthread_mutex_init(&semap->lock, &psharedm);
  pthread_cond_init(&semap->nonzero, &psharedc);
  semap->count = 0;
  return semap;
}

semaphore_t * semaphore_open(char *name) {
  int fd;
  semaphore_t *semap;

  fd = open(name, O_RDWR, 0666);
  if(fd<0)
    return NULL;
  semap = (semaphore_t *) mmap(NULL, sizeof(semaphore_t), PROT_READ|PROT_WRITE,
          MAP_SHARED, fd, 0);
  close(fd);

  return semap;
}

void semaphore_post(semaphore_t *semap) {
  pthread_mutex_lock(&semap->lock);
  if(semap->count == 0)
    pthread_cond_signal(&semap->nonzero);
  semap->count++;
  pthread_mutex_unlock(&semap->lock);
}
void semaphore_wait(semaphore_t *semap) {
  pthread_mutex_lock(&semap->lock);
  while(semap->count == 0)
    pthread_cond_wait(&semap->nonzero, &semap->lock);
  semap->count--;
  pthread_mutex_unlock(&semap->lock);
}

void semaphore_close(semaphore_t *semap) {
  munmap((void *)semap; sizeof(semaphore_t));
}
#+END_SRC
**** 互斥量类型
对于互斥量来说有一个类型属性，对于互斥量来说有下面4种类型：
| 互斥量类型               | 说明                                   |
|--------------------------+----------------------------------------|
| PTHREAD_MUTEX_NORMAL     | 普通锁                                 |
| PTHREAD_MUTEX_ERRORCHECK | 错误锁，同一个线程加锁的话会出现错误   |
| PTHREAD_MUTEX_RECURSIVE  | 递归锁，同一个线程加锁的话可以递归加锁 |
| PTHREAD_MUTEX_DEFAULT    | 前面三种默认一种，通常为普通锁         |
#+BEGIN_SRC C++
/* Return in *KIND the mutex kind attribute in *ATTR.  */
extern int pthread_mutexattr_gettype (__const pthread_mutexattr_t *__restrict
				      __attr, int *__restrict __kind)
     __THROW __nonnull ((1, 2));

/* Set the mutex kind attribute in *ATTR to KIND (either PTHREAD_MUTEX_NORMAL,
   PTHREAD_MUTEX_RECURSIVE, PTHREAD_MUTEX_ERRORCHECK, or
   PTHREAD_MUTEX_DEFAULT).  */
extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     __THROW __nonnull ((1));
#+END_SRC

我们有下面两种情形需要使用递归锁，我们分别来看看这两个情形。第一个情形下面
#+BEGIN_SRC C++
pthread_mutex_t mutex;
void func1(){
    pthread_mutex_lock(&mutex);
    func2();
    pthread_mutex_unlcok(&mutex);
}

void func2(){
    pthread_mutex_lock(&mutex);
    pthread_mutex_unlcok(&mutex);
}
#+END_SRC
如果func1调用了func2,并且func1和func2可以并行执行的话，那么func1调用func2的时候就会锁住。
这样的话，我们不得不提供两个版本func2和func2_locked.虽然func2里面的逻辑可以但是也相当麻烦。
但是如果使用递归锁的话，就可以解决这个问题了。另外一个情形相对比较简单，就是如果信号处理
函数里面也使用同一个锁的话。

*** 可重入与线程安全
可重入这个话题在信号处理已经讨论过了，可重入函数一定是线程安全函数，但是线程安全不一定是可重入的。如果
一个函数可在同一时刻被多个线程安全调用的话，那么这个函数就是线程安全的。对于一些线程不安全函数的，如果
操作系统需要支持线程安全性的话，那么会定义_POSIX_THREAD_SAFE_FUNCTIONS/_SC_THREAD_SAFE_FUNCTIONS，同时对于
一些线程不安全函数，提供一个线程安全的版本，通常以_r结尾。

标准IO提供了函数来保证操作标准IO是线程安全的：
#+BEGIN_SRC C++
int ftrylockfile(FILE* fp);
void flockfile(FILE* fp);
void funlockfile(FILE* fp);
#+END_SRC
但是实际上我们操作标准IO而言的话是不需要使用这些函数的，因为标准IO内部保证线程安全的。如果我们进行信号处理
多次fprintf的话不会hang住，所以内部实现应该是递归锁，在同一个线程内多次调用没有任何问题。标准IO默认提供递归锁
又引入了一个问题，那就是如果我们操作字符的时候，如果每次操作字符都要加锁那么代价是非常大的，所以标准IO还提供了另外
一个接口是允许不加锁的操作字符
#+BEGIN_SRC C++
#include <cstdio>
int getchar_unlocked();
int getc_unlocked(FILE* fp);
int putchar_unlocked();
int putc_unlocked(FILE* fp);
#+END_SRC

*** 线程私有数据
引入线程之后，我们就有必须重新考虑变量作用域的问题。在引入线程之前，我们有全局变量和局部变量。但是在多个线程情况下，
如果我们将线程当做一个单独实体的话，那么多出了一个作用域，就是相对于线程来说的全局变量。这种变量我们称为线程
私有数据。每个线程私有数据对应一个键，通过这个键来获取对线程私有数据的访问权。考虑如果没有这个线程私有数据的话，
那么我们线程里面每个函数都必须将这个对象作为参数传入，何其繁琐。

#+BEGIN_SRC C++
int pthread_key_create(pthread_key_t* keyp,void (*destructor)(void*));
int pthread_key_delete(pthread_key_t* key);
void* pthread_getspecific(pthread_key_t key);
int pthread_setspecific(pthread_key_t key,const void* value);
#+END_SRC
创建的键存放在keyp指向的内存单元，这个键可以被所有线程使用，但是不同线程将这个键关联到不同的线程私有数据上。
每个创建的键都设置了一个析构函数，如果为NULL的话那么析构函数不调用。当线程调用pthread_exit或者是线程执行返回的时候，
析构函数才会调用。key_delete只是释放key这个内存，并不会调用析构函数。

线程对于创建的键的数量是存在限制的，可以通过PTHREAD_KEYS_MAX来获得。线程退出时会尝试调用一次析构函数，如果所有键
绑定的值都已经释放为null的话，那么正常，否则还会尝试调用一次析构函数，直到尝试次数为PTHREAD_DESTRUCTOR_ITERATIONS次数。

*** 取消选项
线程分为是否可以取消，以及如果允许取消的话是延迟还是异步取消。设置线程取消可以通过：
#+BEGIN_SRC C++
//1.PTHREAD_CANCEL_ENABLE
//2.PTHREAD_CANCEL_DISABLE
int pthread_setcancelstate(int state,int* oldstate);
#+END_SRC
默认启动的时候线程是可以取消的。如果线程是不可以取消的话那么pthread_cancel不会杀死线程，只是进行标记。
直到线程变成ENABLE状态之后，在下一个取消点才会进行取消。

这里有一个术语就是取消点，取消点是线程检查是否被取消并且按照请求进行动作的一个位置。我们没有必要记住
所有的取消点，因为pthread本身就提供了一个取消点pthread_testcancel.如果线程允许取消的话，调用这个函数
会判断是否存在取消标记，如果有取消标记的话，那么就会停止线程。

取消时机也分延迟取消还是异步取消，延迟取消就是我们所看到的到达某个同步点才取消，而异步取消的话线程可以在
任意时间取消，而不是遇到取消点才取消。设置取消时机的接口是
#+BEGIN_SRC C++
//1.PTHREAD_CANCEL_DEFERRED
//2.PTHREAD_CANCEL_ASYNCHRONOUS
int pthread_setcanceltype(int type,int* oldtype);
#+END_SRC

*** 线程和信号
每个线程有自己的信号屏蔽字，但是信号的处理是所有线程共享的。进程中的单个信号是递送到单个线程的，如果信号
与硬件故障或者是计时器相关的话，那么信号就会发送到引起该事件的线程中去，而其他的信号则被发送到任意一个线程中。
POSIX.1的线程模型中，异步信号被发送到进程以后，进程中当前没有阻塞该信号的某个线程来处理该信号。

每个线程有自己的信号屏蔽字，如果我们使用sigprocmask的话对于多线程是没有定义的。为此pthread提供了pthread_sigmask
来为每个线程提供线程的信号屏蔽字。此外线程还可以通过调用sigwait来等待一个或者是多个信号发生。语义和sigsuspend一样，
但是可以获得等待到的信号编号。sigwait会首先清除未决的信号，然后打开需要截获的信号，这也意味这在sigwait之前需要屏蔽
需要关心的信号，然后调用sigwait.
#+BEGIN_SRC C++
#include <signal.h>
int pthread_sigmask(int how,const sigset_t* restrict set,sigset_t* restrict oset);
int sigwait(const sigset_t* restrict set,int* restrict signop);
#+END_SRC

使用sigwait可以简化信号处理，允许把异步的信号用同步的方式处理。我们可以将正常线程屏蔽信号，然后只让某一个线程处理信号。
这样能够按照同步方式来处理信号，非常方便。
#+BEGIN_SRC C++
#include <unistd.h>
#include <signal.h>
#include <pthread.h>
#include <cstdio>
#include <cstdlib>
#include <cstring>
int quit_flag=0;
//此线程专门处理信号
void* signal_handler_thread(void* arg){
    sigset_t set;
    sigfillset(&set);
    pthread_sigmask(SIG_BLOCK,&set,NULL);
    sigemptyset(&set);
    sigaddset(&set,SIGINT);
    sigaddset(&set,SIGUSR1);
    sigaddset(&set,SIGUSR2);
    for(;;){
        int signo;
        sigwait(&set,&signo);
        //in a synchronous way.
        printf("%s received\n",strsignal(signo));
        if(signo==SIGINT){
            quit_flag=1;
            return NULL;
        }
    }
}
//main主线程非常轻松，屏蔽了所有的信号，
//而在专门的线程里面以一种同步的方式来处理信号
int main(){
    sigset_t set;
    sigfillset(&set);
    pthread_sigmask(SIG_BLOCK,&set,NULL);
    pthread_t tid;
    pthread_create(&tid,NULL,signal_handler_thread,NULL);
    for(;;){
        sleep(1);
        if(quit_flag==1){
            pthread_join(tid,NULL);
            return 0;
        }
    }
    return 0;
}
#+END_SRC

进程之间发送信号也是可以的。我们也可以传递信号0来判断线程是否存在。
#+BEGIN_SRC C++
#include <signal.h>
int pthread_kill(pthread_t thread,int signo);
#+END_SRC

注意闹钟定时器是进程资源，并且所有的线程共享相同的alarm.所以进程中的多个线程不可能互不干扰地使用闹钟定时器。

*** 线程和fork
#note: 个人觉得相当无用而且异常繁琐。为了保证锁和条件变量的状态，使用到了pthread_atfork.

*** 线程和IO
多线程IO下面读写文件的话，底层能够保证一次read/write的串行化，可以认为是一个原子操作。
但是需要考虑的是，线程需要lseek来定位的话，那么这就是一个非原子操作。因为在lseek和read/write之间的话，
位置可能已经发生了变化。我们可以通过系统调用pread/pwrite来满足我们的需求，这是两个原子操作。

*** API
我们只是打算对于pthread的API做一个简单的回顾，这样我们至少可以知道pthread到底可以做什么事情。
我们打算对于API分为下面这几个部分进行介绍。https://computing.llnl.gov/tutorials/pthreads/
通读这些API之后，对realtime threads这个部分的很多内容不是很理解，包括clock_id,mutex下面protocol等。

**** attr
***** init
     - pthread_attr_init
     - pthread_attr_destroy

***** detach
   - pthread_attr_getdetachstate
   - pthread_attr_setdetachstate
所谓detach就是指线程在运行完成之后会自己退出而不会被join.我们这里可以控制线程是处于detached状态，还是处于joinable的状态。

***** guard
   - pthread_attr_setguardsize
   - pthread_attr_getguardsize
每个线程会存在自己的堆栈，如果访问超过自己的堆栈的话那么可能会修改到其他的线程堆栈的，如果这些堆栈是相连的话。
如果我们设置了guardsize的话，线程堆栈会多开辟guarszie这么大小，当访问到这块多开辟大小的内存的话，那么就会触发SIGSEGV信号。

***** sched
   - pthread_attr_getinheritsched
   - pthread_attr_setinheritsched
   - pthread_attr_getschedparam
   - pthread_attr_setschedparam
   - pthread_attr_getschedpolicy
   - pthread_attr_setschedpolicy
inheritsched可以设置如果我们调用pthread_create创建线程的话，调度策略是自己显示设置还是继承于创建线程的线程。
schedpolicy可以设置调度策略，而schedparam可以设置调度策略所涉及的参数，不过从现在文件里面只有priority这个参数。
调度策略有下面这些. #todo: 调度策略分别是怎么样的???
   - SCHED_FIFO
   - SCHED_RR
   - SCHED_SPORADIC
#+BEGIN_SRC C++
// /usr/include/bits/sched.h
struct sched_param
  {
    int __sched_priority;
  };
#+END_SRC

***** scope
   - pthread_attr_setscope
   - pthread_attr_getscope
文档上面来说的话是说contention scope.包括
   - PTHREAD_SCOPE_SYSTEM // signifying system scheduling contention scope
   - PTHREAD_SCOPE_PROCESS // signifying process scheduling contention scope
process contention scope是指各个线程在同一个进程中竞争被调度的CPU时间，但是并不和其他进程中的线程竞争。
system contention scope是只线程直接和系统范围内其他线程竞争，而不论它们和什么进程关联。

***** stack
   - pthread_attr_getstack
   - pthread_attr_setstack
   - pthread_attr_getstackaddr
   - pthread_attr_setstackaddr
   - pthread_attr_getstacksize
   - pthread_attr_setstacksize
可以设置线程在什么地址上面运行(栈),以及栈大小

**** sync
***** mutex
   - pthread_mutex_init
   - pthread_mutex_destroy
   - pthread_mutex_lock
   - pthread_mutex_timedlock
   - pthread_mutex_trylock
   - pthread_mutex_unlock
   - pthread_mutex_getprioceiling // priority ceiling.
   - pthread_mutex_setprioceiling
   - pthread_mutexattr_init
   - pthread_mutexattr_destroy
   - pthread_mutexattr_getprioceiling
   - pthread_mutexattr_setprioceiling
   - pthread_mutexattr_getprotocol // protocol.
   - pthread_mutexattr_setprotocol
   - pthread_mutexattr_getpshared
   - pthread_mutexattr_setpshared
   - pthread_mutexattr_gettype
   - pthread_mutexattr_settype
shared允许在进程之间共享互斥锁状态，这样进程之间也可以使用互斥锁
   - PTHREAD_PROCESS_SHARED
   - PTHREAD_PROCESS_PRIVATE // 默认值
type是锁的类型包括下面这些
   - PTHREAD_MUTEX_NORMAL // 我们最常用的
   - PTHREAD_MUTEX_ERRORCHECK // 同一线程尝试锁多次会error,这样情况可能会在信号处理时候出现
   - PTHREAD_MUTEX_RECURSIVE // 递归锁，允许多次加锁，但是也需要同样次数解锁
   - PTHREAD_MUTEX_DEFAULT // ???


***** cond
     - pthread_cond_init
     - pthread_cond_destroy
     - pthread_cond_signal
     - pthread_cond_broadcast
     - pthread_cond_timedwait
     - pthread_cond_wait
     - pthread_condattr_init
     - pthread_condattr_destroy
     - pthread_condattr_getclock // clock_id
     - pthread_condattr_setclock
     - pthread_condattr_getpshared
     - pthread_condattr_setpshared

***** rwlock
     - pthread_rwlock_init
     - pthread_rwlock_destroy
     - pthread_rwlock_rdlock
     - pthread_rwlock_timedrdlock
     - pthread_rwlock_tryrdlock
     - pthread_rwlock_wrlock
     - pthread_rwlock_timedwrlock
     - pthread_rwlock_trywrlock
     - pthread_rwlock_unlock
     - pthread_rwlockattr_init
     - pthread_rwlockattr_destroy
     - pthread_rwlockattr_getpshared
     - pthread_rwlockattr_setpshared

***** spinlock
     - pthread_spin_init
     - pthread_spin_destroy
     - pthread_spin_lock
     - pthread_spin_trylock
     - pthread_spin_unlock

***** barrier
   - pthread_barrier_init // 以count初始化,表明有多少个线程需要同步
   - pthread_barrier_destroy
   - pthread_barrier_wait // 同步点，直到所有线程都到这个位置然后继续
   - pthread_barrierattr_init
   - pthread_barrierattr_destroy
   - pthread_barrierattr_getpshared
   - pthread_barrierattr_setpshared
barrier类似于muduo里面的countdownlatch机制

**** control
***** run
     - pthread_create
     - pthread_exit
     - pthread_join
     - pthread_detach

***** cancel
   - pthread_cancel
   - pthread_testcancel
   - pthread_setcancelstate
   - pthread_setcanceltype
   - pthread_cleanup_pop
   - pthread_cleanup_push
对于cancelstate有下面两种
   - PTHREAD_CANCEL_ENABLE // 允许cancel
   - PTHREAD_CANCEL_DISABLE // 不允许cancel
然后type有两种
   - PTHREAD_CANCEL_DEFERRED // cancel被延迟到下一个cancellation point进行，默认行为
   - PTHREAD_CANCEL_ASYNCHRONOUS // cancel立即触发，系统尝试取消线程但是并不保证。
cancellation point有一类函数，如果我们希望在自己构造cancellation point的话，那么我们可以调用pthread_testcancel这个函数，
如果其他线程已经尝试cancel我们的话，我们就会在这个点退出。pthread_cancel就是去cancel某个线程的，pthread_cancel不会阻塞立即返回。
而push和pop就是注册被cancel之后cleanup的回调函数，可能以宏实现然后配合线程局部变量完成。

***** signal
     - pthread_kill
     - pthread_sigmask
     - pthread_atfork // 设置线程在fork时候触发的回调

***** sched
   - pthread_getschedparam
   - pthread_setschedparam
   - pthread_setschedprio
这个和attr部分的sched差不多，允许线程动态地修改调度策略，参数以及运行优先级。

***** resource
   - pthread_getcpuclockid
   - pthread_getconcurrency
   - pthread_setconcurrency
getcpuclockid可以获得clock_id,每一个线程/进程都会绑定一个CPU-time clock,然后通过clock_id来区分。线程可以通过pthread_getcpuclockid获取，
而进程可以通过clock_getcpuclockid获取。取得clock_id之后，我们可以clock_getres来获得时钟精度，clock_gettime来获得运行时间。
还可以timer_create来创建高精度定时器。不过这些内容都是猜测从manpage里面看的，似乎没有任何一本手册提到过这些内容。这些内容都是rt(realtime)范畴的。
#+BEGIN_SRC C++
#include <pthread.h>
#include <cstdio>
#include <cstring>
#include <unistd.h>

int main(){
    clockid_t id;
    pthread_getcpuclockid(pthread_self(),&id);
    // problematic
    struct timespec tp;
//     tp.tv_sec=2;
//     tp.tv_nsec=0;
//     clock_nanosleep(CLOCK_REALTIME, TIMER_ABSTIME,&tp,NULL);
    sleep(2);
    clock_gettime(id,&tp);
    printf("exhausted %lf ms\n",tp.tv_sec*1000.0+tp.tv_nsec/1000000.0);
    clock_getres(id,&tp);
    printf("resolution %lf ms\n",tp.tv_sec*1000.0+tp.tv_nsec/1000000.0);
    return 0;
}
#+END_SRC
#+BEGIN_EXAMPLE
exhausted 2002.648246 ms
resolution 0.000001 ms
#+END_EXAMPLE

#note: 可能和某些具体实现相关
#+BEGIN_SRC C++
/* Global definition.  Needed in pthread_getconcurrency as well.  */
int __concurrency_level;

int
pthread_setconcurrency (level)
     int level;
{
  if (level < 0)
    return EINVAL;

  __concurrency_level = level;

  /* XXX For ports which actually need to handle the concurrency level
     some more code is probably needed here.  */

  return 0;
}
#+END_SRC

***** specific
     - pthread_once
     - pthread_self
     - pthread_key_create
     - pthread_key_delete
     - pthread_getspecific
     - pthread_setspecific

*** 使用注意
**** pthread cancel陷阱
最近几天看core java,对于多线程部分的话提到了最好不要stop,suspend,resume线程。在外部去干扰线程执行的话，容易造成线程资源占用以及运行状态不合理。

下面代码就是最近遇到一个问题的例子。main -> func1 -> func2.然后main等待func1建立完成之后cancel并且join func1.而func1就是join func2.而func2里面尝试持有一个mutex lock.其中mutex lock里面存在字段holder_表示哪个线程持有这个lock.为了确保mutex lock的锁释放正确，会在析构去assert没有任何线程持有这个lock.单独看这个mutex lock实现没有任何问题，但是在这个cancel线程场景下…
#+BEGIN_SRC C++
/* coding:utf-8
 * Copyright (C) dirlt
 */

#include <unistd.h>
#include <linux/unistd.h>
#include <pthread.h>
#include <cassert>
#include <cstdio>

class Lock {
 public:
  Lock():holder_(0){
    pthread_mutex_init(&lock_,NULL);
  }
  ~Lock(){
    assert(holder_==0);
    pthread_mutex_destroy(&lock_);
  }
  void lock() {
    pthread_mutex_lock(&lock_);
    holder_=syscall(__NR_gettid);
  }
  void unlock() {
    holder_=0;
    pthread_mutex_unlock(&lock_);
  }
 private:
  pthread_mutex_t lock_;
  pid_t holder_;
}; // class Lock

static Lock lock;
void* func2(void* arg){
  printf("enter func2\n");
  lock.lock();
  while(1){
    sleep(2);
  }
  lock.unlock();
  printf("exit func2\n");
  return NULL;
}
void* func1(void* arg){
  printf("enter func1\n");
  pthread_t tid;
  pthread_create(&tid,NULL,func2,NULL);
  pthread_join(tid,NULL);
  printf("exit func1\n");
  return NULL;
}
int main() {
  pthread_t tid;
  pthread_create(&tid,NULL,func1,NULL);
  // wait thread func1 and func2 ready.
  sleep(1);
  pthread_cancel(tid);
  pthread_join(tid,NULL);
  printf("exit main\n");
  return 0;
}
#+END_SRC

运行结果为下
#+BEGIN_EXAMPLE
    [zhangyan04@tc-hpc-dev.tc.baidu.com]$ ./a.out
    enter func1
    enter func2
    exit main
    a.out: main.cc:17: Lock::~Lock(): Assertion `holder_==0′ failed.
    已放弃 (core dumped)
#+END_EXAMPLE
可以看到func1以及func2都没有正常退出，但是main函数是正常退出。main函数正常退出的话就会尝试析构全局这个lock对象，而这个lock对象在func2被持有。这就是外部干扰线程的结果。

*对于这个问题解决办法非常简单，就是外部设置退出标记，然后线程去检测这个退出标记的置位，然后让这个线程自己决定如何退出。所以对于线程控制的话，我们更应该使用一种cooperative而不是preemptive的方式来达到。*

** 守护进程
守护进程也是精灵进程(daemon),是一种生存期较长的进程，常常在系统自举时候启动，仅仅在系统关闭时终止。
因为没有控制终端所有在后台运行。常见的守护进程有下面这些：
   - init.系统守护进程，负责启动各个运行层次的特定系统服务。
   - keventd.为内核中运行计划执行的函数提供进程上下文。
   - kampd.对高级电源管理提供支持。
   - kswapd.页面调度守护进程。
   - bdflush.当可用内存到达某个下限的时候，将脏缓冲区从缓冲池(buffer cache)冲洗到磁盘上。
   - kupdated.将脏页面冲洗到磁盘上，以便在系统失效时减少丢失的数据。
   - portmap.将rpc程序号映射为网络端口号。
   - syslogd.系统消息日志服务器。
   - xinted.inted守护进程。
   - nfsd,lockd,rpciod.支持NFS的一组守护进程。
   - crond.在指定的日期和时间执行特定的命令。
   - cupds.打印假脱机进程，处理对系统提出的所有打印请求。

*** daemonize
产生一个daemon程序需要一系列的操作，步骤如下：
   - umask(0).因为我们从shell创建的话，那么继承了shell的umask.这样导致守护进程创建文件会屏蔽某些权限。
   - fork然后使得父进程退出。一方面shell认为父进程执行完毕，另外一方面子进程获得新的pid肯定不为进程组组长，这是setsid前提。
   - setsid来创建新的会话。这时候进程称为会话首进程，称为第一个进程组组长进程同时失去了控制终端。
   - 最好在这里再次fork。这样子进程不是会话首进程，那么永远没有机会获得控制终端。如果这里不fork的话那么会话首进程依然可能打开控制终端。
   - 将当前工作目录更改为根目录。父进程继承过来的当前目录可能mount在一个文件系统上。如果不切换到根目录，那么这个文件系统不允许unmount.
   - 关闭不需要的文件描述符。可以通过_SC_OPEN_MAX来判断最高文件描述符(不是很必须).
   - 然后打开/dev/null复制到0,1,2(不是很必须).
#+BEGIN_SRC C++
void print_ids(const char* name){
    printf("%s:pid=%d,ppid=%d,pgid=%d,sid=%d\n",
           name,getpid(),getppid(),getpgid(0),getsid(0));
    //printf("%s\n",name);
}

void daemonize(){
    umask(0);
    pid_t pid=fork();
    if(pid!=0){
        exit(0);
    }
    sleep(1);
    print_ids("after fork()");
    setsid();
    print_ids("after setsid()");
    pid=fork();
    if(pid!=0){
        exit(0);
    }
    print_ids("after fork()");
    chdir("/");
    long v=sysconf(_SC_OPEN_MAX);
    for(long i=0;i<v;i++){
        close(i);
    }
    open("/dev/null",O_RDWR);
    dup(0);
    dup(0);
}
#+END_SRC
实验之后发现其实控制终端依然还是存在的并且依然可写(不过在关闭之后定位到/dev/null不可写了)。但是如果本次链接断开之后下次重新链接的话，
那么就会失去这个控制终端。其实似乎建立一个这样的东西完全没有必要这么麻烦，甚至最后面setsid和第二次fork都不需要，因为第一个子进程
已经成为一孤儿进程组，shell会话是不会影响到它的。
#+BEGIN_SRC C++
void daemonize(){
    umask(0);
    pid_t pid=fork();
    if(pid!=0){
        exit(0);
    }
    chdir("/");
    long v=sysconf(_SC_OPEN_MAX);
    for(long i=0;i<v;i++){
        close(i);
    }
    open("/dev/null",O_RDWR);
    dup(0);
    dup(0);
}
#+END_SRC

*** 出错处理
我们假设daemon不会将错误信息输出到终端上。如果我们只是写到一个单独的文件，那么非常难以管理。所以有必要有
一个集中设施来管理出错记录。BSD的syslog就是这个集中设施。设施大体分布是这样的：
   - syslogd守护进程专门接受记录，然后决定写文件，本地或者发送到远程主机。配置文件是/etc/syslog.conf
   - 用户进程通过syslog传递到syslogd,通信机制是unix domain socket,文件是/dev/log.
   - TCP/IP可以通过访问UDP 514端口和syslogd通信提交日志。
   - 内核例程通过log函数传递到syslogd,通信机制也是unix domain socket,文件是/dev/klog.

syslog的设施接口是下面这样的：
#+BEGIN_SRC C++
#include <syslog.h>
//facility通常为LOG_USER
void openlog(const char* ident,int option,int facility);
void syslog(int priority,const char* format,...); //priority是facility和level的组合
void closelog();
int setlogmask(int maskpri); //屏蔽的priority
#+END_SRC
如果我们直接使用syslog也是可以，但是这样会损失很多功能，所以还是很推荐使用openlog首先打开，然后再syslog这种方式。
| option     | 说明                                                                               |
|------------+------------------------------------------------------------------------------------|
| LOG_CONS   | 如果不能够通过unix domain socket传递到syslogd,那么直接输出到控制台                 |
| LOG_NDELAY | 立即打开至syslogd的unix domain socket.通常来说默认是syslog第一条记录之后再建立连接 |
| LOG_ODELAY | 不立即打开至syslogd的uds                                                           |
| LOG_PERROR | 日志消息不仅仅发送给syslog,同时写到标准错误上                                      |
| LOG_PID    | 每个消息都包含pid                                                                  |

| level       | 说明                              |
|-------------+-----------------------------------|
| LOG_EMERG   | 紧急状态(系统不可使用),最高优先级 |
| LOG_ALERT   | 必须立即修复的状态                |
| LOG_CRIT    | 严重状态                          |
| LOG_ERR     | 出错状态                          |
| LOG_WARNING | 警告状态                          |
| LOG_NOTICE  | 正常状态                          |
| LOG_INFO    | 信息性消息                        |
| LOG_DEBUG   | 调试消息                          |

看完这个之后我们看看一份syslog.conf的样例配置
#+BEGIN_EXAMPLE
# Log all kernel messages to the console.
# Logging much else clutters up the screen.
#kern.*							/dev/console
kern.*                                                  /var/log/kernel
# Log anything (except mail) of level info or higher.
# Don't log private authentication messages!
*.info;mail.none;authpriv.none;cron.none		/var/log/messages

# The authpriv file has restricted access.
authpriv.*						/var/log/secure

# Log all the mail messages in one place.
mail.*							-/var/log/maillog


# Log cron stuff
cron.*							/var/log/cron

# Everybody gets emergency messages
*.emerg							*

# Save news errors of level crit and higher in a special file.
uucp,news.crit						/var/log/spooler

# Save boot messages also to boot.log
local7.*						/var/log/boot.log
*.*             @tc-sys00.tc.baidu.com
#+END_EXAMPLE
可以看到每个项分两个部分，第一个是priority,第二个就是写的位置。如果*那么都会收到这个message.

#+BEGIN_SRC C++
#include <syslog.h>
int main(){
    openlog("FuckYourAss",0,LOG_EMERG);
    syslog(0,"%s\n","Fuck Your Ass!!!!");
    closelog();
}
#+END_SRC

*** 其他事项
守护进程通常单实例运行的，为了保证是单例运行的话，我们可以通过文件标记或者是文件锁来完成。
在Unix下面守护进程通常有下面这些惯例：
   - 守护进程的锁文件，通常存放在/var/run/<name>.pid
   - 如果守护进程有配置文件的话，那么文件存放在/etc/<name>.conf
   - 守护进程可以使用命令行启动，但是通常是在系统初始化脚本之一存放在/etc/init.d/*下面。
   - 守护进程终止的话我们通常希望重启。而守护进程的父进程通常为init.在/etc/inittab里面为守护进程包含_respawn选项的话，那么守护进程终止的话init会自动重启。
   - 因为守护进程和终端不连接，所以永远接收不到SIGHUP信号。我们可以使用SIGHUP信号来通知守护进程重新载入配置文件。守护进程必须支持这个功能。

** 高级IO
*** 非阻塞IO
首先必须明确为什么需要引入非阻塞IO这个概念。因为系统调用存在低速系统调用，可能使进程永久阻塞住。
通常包括下面这些进程：
   - 某些文件类型比如管道，终端设备和网络设备数据并不存在。
   - 数据不能够被文件立即接受，比如管道无空间或者是网络流控制等。
   - 打开某些类型文件比如调制解调器等等待应答。
   - 对于文件加上了强制锁进行的读写。
   - 某些ioctl操作。
   - 某些进程间通信函数。
但是我们必须区分磁盘IO相关的系统调用，这些并不是低速系统调用。对于非阻塞IO操作的话，如果没有成功的话，
那么不会阻塞而是立即返回一个错误表示EAGAIN.

对于一个给定的描述符设置非阻塞IO属性的话，要不可以通过在open时候指定，要不通过fcntl来修改为O_NONBLOCK状态。

*** 记录锁
建议锁和强制锁之间的差别，建议锁更强调协作方面的特性只是一个软规定，而对于强制锁来说，
如果我们加上强制锁的话那么以阻塞方式来读写的话那么就一定会阻塞，是一个硬性规定。强制锁和建议锁底层都是记录锁。

#note: 我们这里不谈强制锁，似乎没有太大的作用。

记录锁(record locking)的功能是当一个进程正在读或者是修改文件的某一个部分的话，它可以阻塞其他进程修改
同一个文件区域。对于文件区域来说，是一个范围，可以锁几个字节也可以尝试锁一个文件。记录锁有下面这些属性：
   - 进程终止时，进程建立的锁全部释放。
   - 关闭任何一个描述符时，那么这个描述符可以引用的任何所都会被释放。
   - fork出来的子进程继承文件描述符但是却不继承记录锁。
   - exec之后会继承文件描述符和锁。但是如果文件标识设置了close-on-exec的话，那么会自动关闭。
这里可以看到，记录锁是和文件描述符以及进程相关联的。在具体实现可以看到为什么是这样的。

**** 接口
我们使用fcntl来操纵记录锁，那么接口是
#+BEGIN_SRC C++
#include <fcntl.h>
struct flock
  {
    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
#ifndef __USE_FILE_OFFSET64
    __off_t l_start;	/* Offset where the lock begins.  */
    __off_t l_len;	/* Size of the locked area; zero means until EOF.  */
#else
    __off64_t l_start;	/* Offset where the lock begins.  */
    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
#endif
    __pid_t l_pid;	/* Process holding the lock.  */
  };
//cmd可以是F_GETLK,F_SETLK(non-wait),F_SETLKW(wait)
int fcntl(int fd,int cmd,struct flock* lockp);
#+END_SRC
可以看到锁的类型还区分为读写锁，加锁操作分为了阻塞和非阻塞两个版本。如果从字节范围上来看的话，
那么1个锁可能会拆分成为多个锁得可能。假设一开始我们锁住范围[a,b],然后中途释放了[c,d]，那么之后
我们有把锁，分别是[a,c],[d,b].

在这里我们有一个问题需要注意，如果l_len设置为0的话，锁住的大小始终是文件的最末端。如果文件不断
追加写的话，那么记录锁的范围是越来越大的。这样在释放的时候，也要释放对应的范围。

**** 实现
实现上来说，所有的锁都是挂在在v节点表之后的，以链表形式挂接：
#+BEGIN_SRC C++
struct lockf{
    struct lockf* next;
    flag_t flag; //标识
    off_t start; //起始偏移量
    off_t len; //长度
    pid_t pid; //是什么进程尝试锁住文件的
};
#+END_SRC
对于锁来说里面保存了是什么进程锁住文件的，所以子进程并不能够继承父进程的锁而exec可以。

*** IO多路转接
如果我们希望可以监视多个IO操作的话，那么会遇到一个问题。对于阻塞IO的话，我们必须安排一定的顺序来读取，
对于非阻塞IO的话我们必须耗费大量时间在轮询上。另外一种方式就是使用异步信号IO,但是它通常只是告诉我们
有文件描述符准备好了但是在信号处理部分我们还是要轮询一次。IO多路转接(IO multiplexing)就是用来解决这个问题的，
效果相当于构造一个文件描述符表，然后如果可读可写或者是发生异常的话就会返回一个准备好的fd集合。

**** select/pselect
#+BEGIN_SRC C++
#include <sys/select.h>
/* Check the first NFDS descriptors each in READFDS (if not NULL) for read
   readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS
   (if not NULL) for exceptional conditions.  If TIMEOUT is not NULL, time out
   after waiting the interval specified therein.  Returns the number of ready
   descriptors, or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int select (int __nfds, fd_set *__restrict __readfds,
		   fd_set *__restrict __writefds,
		   fd_set *__restrict __exceptfds,
		   struct timeval *__restrict __timeout);

#ifdef __USE_XOPEN2K
/* Same as above only that the TIMEOUT value is given with higher
   resolution and a sigmask which is been set temporarily.  This version
   should be used.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pselect (int __nfds, fd_set *__restrict __readfds,
		    fd_set *__restrict __writefds,
		    fd_set *__restrict __exceptfds,
		    const struct timespec *__restrict __timeout,
		    const __sigset_t *__restrict __sigmask);
#endif
#+END_SRC
pselect相对于改进的话是首先时间信息使用timespect支持到纳秒级别，更加精确。同时时间不会发生修改。
此外还提供了信号屏蔽字。其中nfds表示后面几个fdset里面最大的文件描述符+1.相当于我们告诉select/pselect:
   - 我们关心的描述符有哪些。
   - 关心描述符状态，比如是可读可写还是出现异常状态。
   - 愿意等待多长时间可以永远等待或者是等待一个固定时间，或者是立即返回。
而系统返回：
   - 已准备好的文件描述符数量
   - 哪些文件描述符准备好了。
如果返回-1的话，表示出错那么fds里面内容不变。如果返回0的话表示没有准备好的fd。我们不应该假设
fds不会修改，所以最好每次都重新进行设置。对于timeout的话，如果提前返回的话，那么里面存放的是剩余时间。

这里我们看到有一个fd集合，原则上和sigset_t接口是一样的，但是更简单一些：
#+BEGIN_SRC C++
#define	__FD_SETSIZE		1024
/* fd_set for select and pselect.  */
typedef struct
  {
    /* XPG4.2 requires this member name.  Otherwise avoid the name
       from the global namespace.  */
#ifdef __USE_XOPEN
    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];
# define __FDS_BITS(set) ((set)->fds_bits)
#else
    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];
# define __FDS_BITS(set) ((set)->__fds_bits)
#endif
  } fd_set;

/* Access macros for `fd_set'.  */
#define	FD_SET(fd, fdsetp)	__FD_SET (fd, fdsetp)
#define	FD_CLR(fd, fdsetp)	__FD_CLR (fd, fdsetp)
#define	FD_ISSET(fd, fdsetp)	__FD_ISSET (fd, fdsetp)
#define	FD_ZERO(fdsetp)		__FD_ZERO (fdsetp)
#+END_SRC
可以看到对于一个fd_set最多允许1024个文件描述符进行监听。

这里准备好的情况是这样定义的：
   - 对于读来说的话那么read操作将不会阻塞。
   - 对于写来说的话那么write操作将不会阻塞。
   - 对于异常状态集得话描述符中有一个未决的异常状态比如存在带外数据。
文件描述符本身的阻塞与否不会影响到select/pselect的行为的，select/pselect给出的界面还是阻塞行为的。

**** poll/ppoll
#+BEGIN_SRC C++
#include <poll.h>
/* Type used for the number of file descriptors.  */
typedef unsigned long int nfds_t;

/* Data structure describing a polling request.  */
struct pollfd
  {
    int fd;			/* File descriptor to poll.  */
    short int events;		/* Types of events poller cares about.  */
    short int revents;		/* Types of events that actually occurred.  */
  };

/* Poll the file descriptors described by the NFDS structures starting at
   FDS.  If TIMEOUT is nonzero and not -1, allow TIMEOUT milliseconds for
   an event to occur; if TIMEOUT is -1, block until an event occurs.
   Returns the number of file descriptors with events, zero if timed out,
   or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int poll (struct pollfd *__fds, nfds_t __nfds, int __timeout);

#ifdef __USE_GNU
/* Like poll, but before waiting the threads signal mask is replaced
   with that specified in the fourth parameter.  For better usability,
   the timeout value is specified using a TIMESPEC object.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int ppoll (struct pollfd *__fds, nfds_t __nfds,
		  __const struct timespec *__timeout,
		  __const __sigset_t *__ss);
#+END_SRC
和select/pselect一样，pool提供了接口。其中nfds表示fds数组数量。timeout在这里单位是微秒。
和select/pselect最大的不同是，返回之后并不会修改fds里面fd和events字段内容，产生的事件
直接写在revent字段里面。我们可以看看poll支持的事件有哪些：
| 标识名     | events | revents | 说明                                                               |
|------------+--------+---------+--------------------------------------------------------------------|
| POLLIN     | y      | y       | 可以不阻塞地读取出高优先级之外的数据(等效于PLLRDNORM & POLLRDBAND) |
| POLLRDNORM | y      | y       | 不阻塞地读取普通数据(优先级为0波段数据)                            |
| POLLRDBAND | y      | y       | 不阻塞地读取非0优先级波段数据                                      |
| POLLPRI    | y      | y       | 不阻塞地读取高优先级数据                                           |
| POLLOUT    | y      | y       | 不阻塞地写普通数据                                                 |
| POLLWRNORM | y      | y       | 和POLLOUT相同                                                      |
| POLLWRBAND | y      | y       | 不阻塞地写非0优先级波段数据                                        |
| POLLERR    |        | y       | 已经出错                                                           |
| POLLHUP    |        | y       | 已经挂断                                                           |
| POLLNVAL   |        | y       | 描述符无效                                                         |

**** 自动重启
上面4个都属于系统调用，取决于安装的系统是否默认为信号自动重启。不过在编写应用程序时候最好不要假设这点，
相反应该假设系统调用不会自动重启，所以我们必须检测出错并且errno==EINTR的可能。

*** 异步IO
异步IO是通过信号同时来实现的，并且异步IO对应的只有有限的几个信号。这样在信号处理函数中我们还必须仔细
判断哪些文件描述符是可读，可写或者是异常的。对于BSD派生出来的系统，使用的信号是SIGIO和SIGURG(猜想linux和bsd应该走得很近).
SIGIO是通用异步信号，而SIGURG是用药通知进程在网络连接上有带外数据。为了使用SIGIO的话，需要执行下面三个步骤：
   - 调用signal为SIGIO建立处理函数
   - 使用F_SETOWN为fd设置进程和进程组。因为一旦fd触发信号的话，系统是要决定信号投递到哪个进程和进程组的。
   - 使用F_SETFL来设置O_ASYNC文件状态标志。对于BSD来说仅仅用于终端或者是网络的描述符。
对于SIGURG只需要设置前面两个步骤，信号仅仅是用于支持带外数据的网络连接描述符产生的。
#+BEGIN_SRC C++
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>
#include <signal.h>
#include <cstdio>
#include <cstring>

static int id=0;
void sig_handler(int signo){
    printf("%s received(%d)\n",strsignal(signo),id);
    id++;
}

int main(){
    signal(SIGIO,sig_handler);
    fcntl(0,F_SETOWN,getpid());
    fcntl(0,F_SETFL,fcntl(0,F_GETFL) | O_ASYNC);
    pause();
    return 0;
}
#+END_SRC

#+BEGIN_EXAMPLE
//发送多次SIGIO信号之后才被pause所捕获到
[dirlt@localhost.localdomain]$ ./a.out
1I/O possible received(0)
I/O possible received(1)
I/O possible received(2)
I/O possible received(3)
I/O possible received(4)
I/O possible received(5)
I/O possible received(6)
I/O possible received(7)
I/O possible received(8)
I/O possible received(9)
I/O possible received(10)
I/O possible received(11)
I/O possible received(12)
I/O possible received(13)
I/O possible received(14)
#+END_EXAMPLE

*** readv/writev
readv和writev能够将分散的多块缓冲区一次性读出和写入，而仅仅是是用一次系统调用
#+BEGIN_SRC C++
#include <sys/uio.h>

/* Structure for scatter/gather I/O.  */
struct iovec
  {
    void *iov_base;	/* Pointer to data.  */
    size_t iov_len;	/* Length of data.  */
  };
/* Read data from file descriptor FD, and put the result in the
   buffers described by IOVEC, which is a vector of COUNT `struct iovec's.
   The buffers are filled in the order specified.
   Operates just like `read' (see <unistd.h>) except that data are
   put in IOVEC instead of a contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t readv (int __fd, __const struct iovec *__iovec, int __count);

/* Write data pointed by the buffers described by IOVEC, which
   is a vector of COUNT `struct iovec's, to file descriptor FD.
   The data is written in the order specified.
   Operates just like `write' (see <unistd.h>) except that the data
   are taken from IOVEC instead of a contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t writev (int __fd, __const struct iovec *__iovec, int __count);
#+END_SRC
读取的话是首先填满第一个缓冲区，然后填写第二个缓冲区。写入的话也是按照iovec的顺序来写入的。

*** 存储映射IO
存储映射IO(memoryy-mapped IO)使得一个磁盘文件于存储空间中的一个缓冲区相映射。这样读取缓冲区的内容就
相当读取磁盘文件的内容，同样如果写缓冲区的话就直接修改文件。映射区域和具体实现相关，但是通常映射在
堆栈之间的存储区域内部。

#+BEGIN_SRC C++
#include <sys/mman.h>
/* Map addresses starting near ADDR and extending for LEN bytes.  from
   OFFSET into the file FD describes according to PROT and FLAGS.  If ADDR
   is nonzero, it is the desired mapping address.  If the MAP_FIXED bit is
   set in FLAGS, the mapping will be at ADDR exactly (which must be
   page-aligned); otherwise the system chooses a convenient nearby address.
   The return value is the actual mapping address chosen or MAP_FAILED
   for errors (in which case `errno' is set).  A successful `mmap' call
   deallocates any previous mapping for the affected region.  */
extern void *mmap (void *__addr, size_t __len, int __prot,
		   int __flags, int __fd, __off_t __offset) __THROW;

/* Deallocate any mapping for the region starting at ADDR and extending LEN
   bytes.  Returns 0 if successful, -1 for errors (and sets errno).  */
extern int munmap (void *__addr, size_t __len) __THROW;

/* Change the memory protection of the region starting at ADDR and
   extending LEN bytes to PROT.  Returns 0 if successful, -1 for errors
   (and sets errno).  */
extern int mprotect (void *__addr, size_t __len, int __prot) __THROW;

/* Synchronize the region starting at ADDR and extending LEN bytes with the
   file it maps.  Filesystem operations on a file being mapped are
   unpredictable before this is done.  Flags are from the MS_* set.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int msync (void *__addr, size_t __len, int __flags);
#+END_SRC

对于mmap来说：
   - addr表示我们希望映射到什么地址上，这只是一个建议通常设置为0即可。
   - fd就是文件描述符，offset表示偏移位置，len表示开辟的内存空间大小。
对于prot(protection)有下面这几个值：
| prot       | 说明             |
|------------+------------------|
| PROT_READ  | 映射区可读       |
| PROT_WRITE | 映射区可写       |
| PROT_EXEC  | 映射区可执行     |
| PROT_NONE  | 映射区不可以访问 |
对于flag有下面资格几个值：
| flag        | 说明                                                         |
|-------------+--------------------------------------------------------------|
| MAP_FIXED   | 说明地址必须为addr,这样容易造成不可一致性一般不使用          |
| MAP_SHARED  | 标记如果修改的话那么修改对应磁盘文件                         |
| MAP_PRIVATE | 标记如果修改的话那么只是修改本地的副本，而不会修改到磁盘文件 |
通常来说mmap分配出的内存和大小是按照_SC_PAGE_SIZE来对齐的。与mmap相关的两个信号是这样的SIGSEGV
和SIGBUS.如果我们映射文件为1K,_SC_PAGE_SIZE=4K的话，那么我们访问对应1K没有任何问题，
如果访问1K以外4K以内，因为内存分配出来了所以访问没有问题，但是没有对应文件那么返回SIGBUS.
如果访问4K以外的话，因为没有分配内存那么返回SIGSEGV.

#+BEGIN_SRC C++
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <signal.h>

void signal_handler(int signo){
    printf("%s received\n",strsignal(signo));
    exit(0);
}

int main(){
    signal(SIGSEGV,signal_handler);
    signal(SIGBUS,signal_handler);
    struct stat stat_buf;
    stat("main.cc",&stat_buf);
    int fd=open("main.cc",O_RDWR);
    char* addr=(char*)mmap(NULL,stat_buf.st_size,PROT_READ | PROT_WRITE,MAP_SHARED,fd,0);
    close(fd);
    getchar(); //这个地方将main.cc删除掉
    printf("change last one byte\n");
    addr[stat_buf.st_size-1]='x';
    msync(addr,stat_buf.st_size,MS_SYNC); //最后还尝试进行同步
    munmap(addr,stat_buf.st_size);
    return 0;
}
#+END_SRC
我们这里并没有复现SIGBUS这个错误，而且尝试了很多情况也没有SIGBUS这个问题。我在想如果已经分配出来的话，
那么在上面操作都是允许的。如果底层没有文件对应的话，那么写就没有任何效果。

mprotect可以修改内存的访问权限，prot字段和mmap的prot字段含义对应。msync的flags有下面这几个：
   - MS_SYNC将页面冲洗到被映射的文件同步返回。
   - MS_ASYNC将页面冲洗到被映射的文件中异步返回。
   - MS_INVALIDATE通知操作系统丢弃与底层存储器没有永不的任何页。
munmap不会使得映射区的内容写到磁盘文件上，MAP_SHARED磁盘文件的更新是通过系统自带的虚存算法来进行自动更新的，
而对于MAP_PRIVATE的存储区域就直接丢弃。

*** linux aio
前几天准备公司内部关于异步编程交流的时候，想到看看linux aio。这个很早之前在百度的时候就听同事说过，但是一直没有机会看看API以及如何使用。
趁着这个机会稍微翻了一些API这里稍微总结一下吧（其实看的还是不深入，不过稍微有点概念了）。可以参考下面这些链接：
   - http://www.kernel.org/doc/man-pages/online/pages/man2/io_setup.2.html
   - http://hi.baidu.com/_kouu/blog/item/e225f67b337841f42f73b341.html 深入分析
linux aio的API大抵包括下面这些：
   - // #include <libaio.h>
   - io_setup  // create aio context
   - io_submit // submit aio task
   - io_getevents // poll aio completion
   - io_destroy // destroy aio context
   - io_cancel // cancel aio task
这个API接口只能够用于disk IO而不能够用于network IO上。

#+BEGIN_SRC C++
int io_setup(unsigned nr_events, aio_context_t *ctxp);
int io_destroy(aio_context_t ctx);
#+END_SRC
创建和销毁aio context非常简单无须多言。

#+BEGIN_SRC C++
int io_submit(aio_context_t ctx_id, long nr, struct iocb **iocbpp);
#+END_SRC
可以看到可以提交多个task.具体每个task都是通过struct iocb来指定的。这个结构可以在/usr/include/linux/aio_abi.h里面找到。
#+BEGIN_SRC C++
/* include/linux/aio_abi.h
 *
 * Copyright 2000,2001,2002 Red Hat.
 *
 * Written by Benjamin LaHaise <bcrl@kvack.org>
 *
 * Distribute under the terms of the GPLv2 (see ../../COPYING) or under
 * the following terms.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation is hereby granted, provided that the above copyright
 * notice appears in all copies.  This software is provided without any
 * warranty, express or implied.  Red Hat makes no representations about
 * the suitability of this software for any purpose.
 *
 * IN NO EVENT SHALL RED HAT BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
 * SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF
 * THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF RED HAT HAS BEEN ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * RED HAT DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND
 * RED HAT HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
 * ENHANCEMENTS, OR MODIFICATIONS.
 */
#ifndef __LINUX__AIO_ABI_H
#define __LINUX__AIO_ABI_H

#include <linux/types.h>
#include <asm/byteorder.h>

typedef unsigned long	aio_context_t;

enum {
	IOCB_CMD_PREAD = 0,
	IOCB_CMD_PWRITE = 1,
	IOCB_CMD_FSYNC = 2,
	IOCB_CMD_FDSYNC = 3,
	/* These two are experimental.
	 * IOCB_CMD_PREADX = 4,
	 * IOCB_CMD_POLL = 5,
	 */
	IOCB_CMD_NOOP = 6,
	IOCB_CMD_PREADV = 7,
	IOCB_CMD_PWRITEV = 8,
};

/*
 * Valid flags for the "aio_flags" member of the "struct iocb".
 *
 * IOCB_FLAG_RESFD - Set if the "aio_resfd" member of the "struct iocb"
 *                   is valid.
 */
#define IOCB_FLAG_RESFD		(1 << 0)

/* read() from /dev/aio returns these structures. */
struct io_event {
	__u64		data;		/* the data field from the iocb */
	__u64		obj;		/* what iocb this event came from */
	__s64		res;		/* result code for this event */
	__s64		res2;		/* secondary result */
};

#if defined(__LITTLE_ENDIAN)
#define PADDED(x,y)	x, y
#elif defined(__BIG_ENDIAN)
#define PADDED(x,y)	y, x
#else
#error edit for your odd byteorder.
#endif

/*
 * we always use a 64bit off_t when communicating
 * with userland.  its up to libraries to do the
 * proper padding and aio_error abstraction
 */

struct iocb {
	/* these are internal to the kernel/libc. */
	__u64	aio_data;	/* data to be returned in event's data */
	__u32	PADDED(aio_key, aio_reserved1);
				/* the kernel sets aio_key to the req # */

	/* common fields */
	__u16	aio_lio_opcode;	/* see IOCB_CMD_ above */
	__s16	aio_reqprio;
	__u32	aio_fildes; // 文件fd

	__u64	aio_buf; // buffer地址
	__u64	aio_nbytes; // 字节数
	__s64	aio_offset; // 偏移

	/* extra parameters */
	__u64	aio_reserved2;	/* TODO: use this for a (struct sigevent *) */

	/* flags for the "struct iocb" */
	__u32	aio_flags;

	/*
	 * if the IOCB_FLAG_RESFD flag of "aio_flags" is set, this is an
	 * eventfd to signal AIO readiness to
	 */
	__u32	aio_resfd; // 如果设置RESFD标记的话，那么当完成这个操作的话也会通知这个fd。
}; /* 64 bytes */

#undef IFBIG
#undef IFLITTLE

#endif /* __LINUX__AIO_ABI_H */
#+END_SRC
最常用的大概就是pread和pwrite操作。

发起之后的话，可以有两种方式得到通知：1）使用我RESFD 2）使用io_getevents。我们主要看第二个方式。看看API
#+BEGIN_SRC C++
int io_getevents(aio_context_t ctx_id, long min_nr, long nr,
                 struct io_event *events, struct timespec *timeout);
int io_cancel(aio_context_t ctx_id, struct iocb *iocb,
                 struct io_event *result);
#+END_SRC
可以看到非常类似epoll的返回，返回借口是io_event（在上面有说明，各个字段含义也很明确）。

** 进程间通信
unix系统下面的IPC(inteprocess communication)主要分为下面这几种：
   - pipe
   - fifo
   - 消息队列
   - 信号量
   - 共享存储
   - uds(unix domain socket)
   - 套接字
其中套接字可以跨机器进程通信，而之前几类都是单机进程之间通信。套接字有专门一节用于说明，
这节仅仅说前面几类单机进程通信手段。unix domain socket也属于套接字范围，所以在这里没有单独叙述。

*** pipe
管道是最古老的unix ipc，几乎所有的unix系统上都会提供这种通信机制。但是管道有两种局限性：
   - 半双工。
   - 必须具备进程关系，比如父子进程。
fifo没有第二种局限性，而uds两种局限性都没有。产生管道非常简单
#+BEGIN_SRC C++
#include <unistd.h>
int pipe(int fd[2]);
#+END_SRC
这样fd(0)可用用来读，fd(1)可以用来写。对于理解管道的话，我们最好理解为fd(0)和fd(1)之间还有一个
管道缓冲区。因为管道有这样的行为，如果多个同时写的话，如果一次写的字节数小于PIPE_BUF的话，那么
可以保证之间是没有穿插行为的，

本质上pipe可以认为是一个匿名的fifo,而实际的fifo则是一个命名的fifo.所以如果使用fstat来测试的话，
S_ISFIFO是成功的。和套接字一样，如果写端关闭的话那么读端读取返回0，如果读端关闭的话那么写端会产生SIGPIPE信号错误，
返回错误为EPIPE.

#+BEGIN_SRC C++
#include <sys/stat.h>
#include <sys/wait.h>
#include <unistd.h>
#include <cstring>
#include <cstdlib>
#include <cstdio>

int main(){
    int fd[2];
    pipe(fd);
    struct stat stat_buf;
    fstat(fd[0],&stat_buf);
    printf("PIPE_BUF=%d,S_ISFIFO=%d\n",
           fpathconf(fd[0],_PC_PIPE_BUF),
           S_ISFIFO(stat_buf.st_mode));
    pid_t pid=fork();
    if(pid==0){//child
        close(fd[1]);
        char buf[1024];
        read(fd[0],buf,sizeof(buf));
        printf("%s\n",buf);
        exit(0);
    }
    close(fd[0]);
    write(fd[1],"hello,world",strlen("hello,world")+1);
    wait(NULL);
    return 0;
}
#+END_SRC

#+BEGIN_EXAMPLE
[dirlt@localhost.localdomain]$ ./a.out
PIPE_BUF=4096,S_ISFIFO=1
hello,world
#+END_EXAMPLE

管道pipe还有另外两个比较有用的函数分别是
#+BEGIN_SRC C++
#include <cstdio>
FILE* popen(const char* cmd,const char* type);
int pclose(FILE* fp);
#+END_SRC
API看上去和打开文件一样，只不过打开的是一个执行命令。对于type来说只允许是"r"或者是"w".
pclose返回的结果和system一样，可能会返回执行命令的内容，如果shell不成功返回127,如果接收到信号退出的话，
那么返回128+信号编号。实现上我们值得思考一下，就是popen通常来说肯定是创建了一个进程，然后FILE里面记录的
fd必然和这个进程号做了一个绑定。不然我们在pclose使用FILE*必须能够找到，我们应该wait什么进程终止。
在pclose必须fclose掉句柄，不然如果作为一输入命令的话那么会一直等待输入完成。

#+BEGIN_SRC C++
#include <sys/stat.h>
#include <sys/wait.h>
#include <unistd.h>
#include <cstring>
#include <cstdlib>
#include <cstdio>

int main(){
    FILE* fp=popen("cat > tmp.txt","w");
    fputs("hello,world\n",fp);
    int status=pclose(fp);
    printf("status:%d\n",status);
    return 0;
}
#+END_SRC

*** fifo
这里的fifo是指命名fifo.和管道特征一样，一次字节小于PIPE_BUF保证不会穿插，并且没有写端读端返回0,没有读端
写端产生SIGPIPE并且返回EPIPE错误，测试类型为S_ISFIFO.命名fifo依赖于特殊文件，然后通过读写文件来进行数据传递。
#+BEGIN_SRC C++
#include <sys/stat.h>
int mkfifo(const char* pathname,mode_t mode);
#+END_SRC
如果我们只读打开的话，那么会等待直到某个进程为写打开fifo.如果设置O_NONBLOCK打开的话，那么会立刻返回没有错误。
如果我们只写打开的话，那么会等待直到某个进程为读打开fifo.如果设置O_NNOBLOCK打开的话，那么会立刻返回错误ENXIO.
#+BEGIN_SRC C++
int main(){
    mkfifo("./fifo",0666);
    pid_t pid=fork();
    if(pid==0){
        int fd=open("./fifo",O_RDONLY);
        char buf[1024];
        read(fd,buf,sizeof(buf));
        printf("%s\n",buf);
        close(fd);
        exit(0);
    }
    int fd=open("./fifo",O_WRONLY);
    write(fd,"hello,world",strlen("hello,world")+1);
    close(fd);
    wait(NULL);
    unlink("./fifo");
    return 0;
}
#+END_SRC

*** XSI IPC
XSI IPC包括的就是消息队列，信号量和共享存储，他们有很多相似之处，所以在开头我们介绍相似之处的功能。
首先需要说明的是IPC相当于重复了一次文件的语义，并且在底层实现上可能就是通过文件来完成的。在学习IPC
的时候，尽可能地对比和文件的接口。

**** 创建标识
和文件的文件描述符类似，IPC也是通过一个非负整数来表示一个IPC资源的，然后之后的操作都是针对这个id来引用
ipc资源的。但是必须注意的是，这个非负整数并不一定很小，虽然获得这个整数也是通过+1来得到的，但是注意
IPC资源是全局的，所以在得到这个整数之前可能尝试获取多次了IPC资源。

和文件的open对象，我们需要打开某个东西才能够获得这个IPC标识。在文件下面是文件路径，在IPC下面是key_t,
在<sys/types.h>里面定义，可以认为是一个整数。从key_t到IPC标识这个过程内核来完成，接口如下：
#+BEGIN_SRC C++
int xxxget(key_t key,int flag); /返回IPC标识
#+END_SRC
这个key_t如何指定有几种方法：
   - key_t指定为IPC_PRIVATE的话，那么每次都会创建一个新IPC标识。
   - 通过ftok函数来生成一个key_t
#+BEGIN_SRC C++
#include <sys/ipc.h>
key_t ftok(const char* path,int id); //id在[0,255]
#+END_SRC
ftok必须引用一个已经存在的路径。底层实现可能是得到path的st_dev和st_ino两个字段，然后配合id来生成key_t.但是也可能会出现重复。
对于IPC_PRIVATE来说每次都会创建，而对于ftok来说的话，flag有IPC_CREATE | IPC_EXCL两个参数，和open类似，来获取当前IPC标识或者是创建。
同时还需要注意的是，flag的低9位是表示权限的，如果我们要允许读写的话那么必须指定0666.

**** 权限结构
对于每一个IPC结构都设置了ipc_perm结构，规定了权限和所有者。
#+BEGIN_SRC C++
#include <sys/ipc.h>
/* Data structure used to pass permission information to IPC operations.  */
struct ipc_perm
  {
    __key_t __key;			/* Key.  */
    __uid_t uid;			/* Owner's user ID.  */
    __gid_t gid;			/* Owner's group ID.  */
    __uid_t cuid;			/* Creator's user ID.  */
    __gid_t cgid;			/* Creator's group ID.  */
    unsigned short int mode;		/* Read/write permission.  */
    unsigned short int __pad1;
    unsigned short int __seq;		/* Sequence number.  */
    unsigned short int __pad2;
    unsigned long int __unused1;
    unsigned long int __unused2;
  };
#+END_SRC
对于uid和gid都是有效的uid和gid.通常来说我们只需要uid和gid,但是因为系统没有内置保存设置uid和gid,所以在权限结构
里面显示存在这样的cuid和cgid字段。通常我们可以修改的就是uid,gid以及mode,和chown/chmod对应。

**** 资源限制
XSI IPC都有内置限制(built-in limit),大多数可以通过重新配置内核而加以修改。在Linux下面我们可以通过ipcs -l来显示
先关的ipc限制，修改限制可以用过sysctl完成。

**** 优点和缺点
XSI IPC有下面这些问题。首先IPC结构没有引用计数，这就意味如果不显示调用的话那么资源会一直保留，即使没有人使用这个IPC的话也一直会存在于
系统中，直到显式现出内容和系统重启，或是通过外部命令ipcrm来删除。其次最重要的一点是，这个东西太像文件系统了，
整个Unix系统的理念就是所有对象都是文件，比如open,read,write,select,poll都是操作文件描述符的，甚至unix socket也统一到了
这个接口上，而ipc因为没有抽象导致需要提供一系列辅助的API来构建自己的体系。优点可能就是比较快吧，但是实测的时候
发现其他设施效率并不会很差，但是却有着一致的接口。在后面打算提供几种代替的方案来尽可能地不使用XSI IPC.
   - 消息队列使用unix domain socket来代替。
   - 信号量通过进程共享的pthread和共享内存代替(另外实现方式).信号量主要注重于同步，所以我们给出的方案也是注重于同步。

另外因为IPC是全局的并且没有引用计数，所以如果需要删除ipc的话那么必须使用外部命令ipcrm来删除。而ipcrm不允许批量删除所有的
IPC对象，所以我们需要下面辅助脚本实现
#+BEGIN_SRC Python
#!/usr/bin/env python
#coding:gbk
#Copyright (c) Baidu.com, Inc. All Rights Reserved
#author:zhangyan04(@baidu.com)

import os
data=filter(lambda x:x.strip(),os.popen('ipcs').read().split('\n'))
mem=[]
sem=[]
msg=[]
for x in data:
    if(x.find('Shared Memory Segments')!=-1):
        mode=mem
    elif(x.find('Semaphore Arrays')!=-1):
        mode=sem
    elif(x.find('Message Queues')!=-1):
        mode=msg
    elif(x.startswith('key')):
        continue
    else:
        (key,id,owner,perms,used,msgs)=x.split()
        mode.append((key,id,owner,perms,used,msgs))
for x in mem:
    os.system('ipcrm -m %s'%(x[1]))
for x in sem:
    os.system('ipcrm -s %s'%(x[1]))
for x in msg:
    os.system('ipcrm -q %s'%(x[1]))
#+END_SRC

*** 消息队列
消息队列由内核来管理，每一个队列通过一个队列ID来识别(queue ID).每一个消息队列都有一个结构msgid_ds与其关联
#+BEGIN_SRC C++
/* Structure of record for one message inside the kernel.
   The type `struct msg' is opaque.  */
struct msqid_ds
{
  struct ipc_perm msg_perm;	/* structure describing operation permission */
  __time_t msg_stime;		/* time of last msgsnd command */
  unsigned long int __unused1;
  __time_t msg_rtime;		/* time of last msgrcv command */
  unsigned long int __unused2;
  __time_t msg_ctime;		/* time of last change */
  unsigned long int __unused3;
  unsigned long int __msg_cbytes; /* current number of bytes on queue */
  msgqnum_t msg_qnum;		/* number of messages currently on queue */
  msglen_t msg_qbytes;		/* max number of bytes allowed on queue */
  __pid_t msg_lspid;		/* pid of last msgsnd() */
  __pid_t msg_lrpid;		/* pid of last msgrcv() */
  unsigned long int __unused4;
  unsigned long int __unused5;
};
#+END_SRC
通过这个结构我们可以看到消息队列记录了最后一次发送和接收消息时间以及当前有多少条消息和字节内容在消息队列中。

因为消息队列是由内核来管理的，所以就存在一定的限制，包括：
   - 一次可发送最大消息的字节数目，linux2.4.22为8192
   - 一个特定队列中最大字节数，即所有消息字节数之和，linux2.4.22为16384
   - 系统中最大消息队列数，linux2.4.22为16

关于消息队列的API有下面这些：
#+BEGIN_SRC C++
/* Message queue control operation.  */
//cmd可以为IPC_STAT表示获取属性，IPC_SET表示设置属性，IPC_RMID表示删除消息队列
extern int msgctl (int __msqid, int __cmd, struct msqid_ds *__buf) __THROW;

/* Get messages queue.  */
extern int msgget (key_t __key, int __msgflg) __THROW;

/* Receive message from message queue.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t msgrcv (int __msqid, void *__msgp, size_t __msgsz,
		       long int __msgtyp, int __msgflg);

/* Send message to message queue.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int msgsnd (int __msqid, __const void *__msgp, size_t __msgsz,
		   int __msgflg);


//对于msgrcv和msgsnd里面的const void*结构应该如下：
#ifdef __USE_GNU
/* Template for struct to be used as argument for `msgsnd' and `msgrcv'.  */
struct msgbuf
  {
    long int mtype;		/* type of received/sent message */
    char mtext[1];		/* text of the message */
  };
#endif
//其中mtext为悬挂字节
#+END_SRC

对于msgsnd来说，如果flag指定为IPC_NOWAIT的话，那么如果消息列队已满的话，那么不会阻塞而是理解返回EAGAIN.
阻塞情况在下面情况会恢复：
   - 消息队列有数据了。
   - 消息队列删除了，返回错误EIDRM
   - 发生信号中断而且没有自动重启，返回EINTR.

对于msgrcv来说，如果flag被指定为IPC_NOWAIT的话，和msgsnd效果一样。如果flag指定为MSG_NOERROR的话，如果
接收到的信息大于nbytes的话，那么信息被截断，如果没有设置的话那么会返回错误E2BIG.对于type参数来说：
   - type==0.消息队列第一个消息
   - type>0.消息队列第一个类型为type消息
   - type<0.返回消息队列中类型<abs(type)的消息，如果存在多个的话那么返回第一个类型最小的消息。

可以看到消息队列是基于消息并且由内核管理，那么不可避免需要设置一个消息上限。但是这个上限可能是不可移植的。
消息队列提供比较方便的功能一方面是信息的记录，另外一方面是消息的过滤，这点它的代替产物unix domain soket可能并没有直接提供，
但是可以在应用层面完成消息划分以及消息按照类型或者是id过滤。
#+BEGIN_SRC C++
#include <unistd.h>
#include <sys/msg.h>
#include <cstdio>
#include <cstring>

struct message{
    long int mtype;
    char mtext[512];
};
int main(){
    int msgid=msgget(IPC_PRIVATE,0666);
    message snd;
    snd.mtype=911;
    strcpy(snd.mtext,"help");
    if(msgsnd(msgid,&snd,5,0)==-1){
        printf("msgsnd %m\n");
        return -1;
    }
    struct msqid_ds ds;
    if(msgctl(msgid,IPC_STAT,&ds)==-1){
        printf("msgctl IPC_STAT %m\n");
        return -1;
    }
    printf("current bytes:%d,current number:%d,max bytes:%d\n",
           ds.__msg_cbytes,ds.msg_qnum,ds.msg_qbytes);
    message rcv;
    if(msgrcv(msgid,&rcv,512,910,IPC_NOWAIT)==-1){
        printf("msgrcv1 %m\n");
    }
    if(msgrcv(msgid,&rcv,521,911,0)==-1){
        printf("msgrcv2 %m\n");
        return -1;
    }
    printf("%s\n",rcv.mtext);
    if(msgctl(msgid,IPC_RMID,NULL)==-1){
        printf("msgctl IPC_RMID %m\n");
    }
    return 0;
}
#+END_SRC
#+BEGIN_EXAMPLE
[dirlt@localhost.localdomain]$ ./a.out
current bytes:5,current number:1,max bytes:16384
msgrcv1 No message of desired type
help
#+END_EXAMPLE

*** 信号量
信号量主要用于进行多进程之间同步的。通常来说针对资源的话，提供是类似于操作系统里面提到的PV操作。
不过XSI的信号量要复杂得多，XSI的信号量提供的是一个信号集合。对于每一个信号量集都下面这样的信息结构
#+BEGIN_SRC C++
/* Data structure describing a set of semaphores.  */
struct semid_ds
{
  struct ipc_perm sem_perm;		/* operation permission struct */
  __time_t sem_otime;			/* last semop() time */
  unsigned long int __unused1;
  __time_t sem_ctime;			/* last time changed by semctl() */
  unsigned long int __unused2;
  unsigned long int sem_nsems;		/* number of semaphores in set */
  unsigned long int __unused3;
  unsigned long int __unused4;
};
#+END_SRC
通常来说一个信号集包括下面这些属性：
   - 信号集资源数目
   - 最后操作这个信号集的pid
   - 等待资源数目可用的进程数
   - 等待资源数目==0的进程数(#todo: 什么应用场景)
可以看到下面提供的接口都可以获取或者是设置这个属性。

创建一个信号量集的话，可以使用下面这个接口：
#+BEGIN_SRC C++
#include <sys/sem.h>
int semget(key_t key,int nsems,int flag);
#+END_SRC
其中nsems表示想创建的信号量集合个数，而flag含义和消息队列一样允许IPC_CREAT和IPC_EXCL.低9位为权限。

控制这个信号集的话可以使用下面这个接口：
#+BEGIN_SRC C++
#include <sys/sem.h>
union semun{
   int val;
   struct semid_ds* buf;
   unsigned short* array;
};
int semctl(int semid,int semnum,int cmd,...(union semun* arg));
#+END_SRC
semnum用于选定集合中某个特性的信号量，不同cmd情况下面可能不使用这个字段。cmd有下面这些选项：
   - IPC_STAT 得到semid_ds信息
   - IPC_SET 设置semid_ds信息
   - IPC_RMID 删除这个信号量集
   - GETVAL +semnum,+val得到某个信号量的资源个数
   - SETVAL +semnum,+val设置某个信号量的资源个数
   - GETPID +semnum,得到最后操作某个信号量的pid
   - GETNCNT +semnum,得到等待资源的进程个数
   - GETZCNT +semnum,得到等待资源==0的进程个数
   - GETALL +array得到所有信号量的资源个数
   - SETALL +array设置所有信号量的资源个数

最后一个接口是操作信号量集的接口。这个接口允许批量操作信号集并且以原子操作方式完成。
#+BEGIN_SRC C++
#include <sys/sem.h>
struct sembuf{
    unsigned short sem_num; //number index in sem set
    short sem_op; //>0 <0 ==0
    short sem_flag; //IPC_NOWAIT,SEM_UNDO
};
int semop(int semid,struct sembuf semoparray[],size_t nops);
#+END_SRC
语义就是进行每个semoparry里面的操作，并且以原子方式操作。sem_num表示我们操作第几个信号量。
这里需要解释一下sem_op和sem_flag.首先如果sem_flag指定为SEM_UNDO的话，那么可以认为sem_op取了反就是，
SEM_UNDO的意思就是说撤销刚才的操作。
   - sem_op > 0,那么相当于释放资源
   - sem_op < 0,那么相当于获取资源
      - 如果资源充足的话，那么操作没有问题
      - 如果资源不充足但是设置了IPC_NOWAIT的话，那么立即出错返回EAGAIN.
      - 如果资源不充足没有设置IPC_NOTWAIT的话，等待资源进程个数+1,立即阻塞直到
         - 资源可用
         - 系统删除信号量，那么返回错误EIDRM
         - 信号中断返回EINTR,等待资源进程个数-1
   - sem_op==0,那么相当于等待信号量值变为0
      - 如果为0那么立即返回
      - 如果不为0并且设置IPC_NOWAIT的话，那么立即出错返回EAGAIN.
      - 如果不为0并且没有设置IPC_NOWAIT的话，那么等待资源==0的进程个数+1,立即阻塞直到
         - 资源个数==0
         - 系统删除信号量，返回错误EIDRM
         - 信号中断返回EINTR,等待资源==0的进程个数-1

其实信号量的接口还是非常易于理解的，但是却没有必要，很少有情况我们需要操作多个信号集。
下面一个通过信号量来同步父子进程的例子
#+BEGIN_SRC C++
#include <unistd.h>
#include <sys/sem.h>
#include <sys/wait.h>
#include <cstdio>
#include <cstring>

int main(){
    int semid=semget(IPC_PRIVATE,1,0666);
    int value=0;
    semctl(semid,0,SETVAL,&value);

    pid_t pid=fork();
    if(pid==0){//child
        struct sembuf buf;
        buf.sem_num=0;
        buf.sem_op=-1;
        printf("child wait to exit\n");
        semop(semid,&buf,1);
        printf("child about to exit\n");
        return 0;
    }
    sleep(2);
    struct sembuf buf;
    buf.sem_num=0;
    buf.sem_op=1;
    printf("tell child ready\n");
    semop(semid,&buf,1);
    wait(NULL);

    //delete it
    semctl(semid,0,IPC_RMID);
    return 0;
}
#+END_SRC
#+BEGIN_EXAMPLE
[dirlt@localhost.localdomain]$ ./a.out
child wait to exit
tell child ready
child about to exit
#+END_EXAMPLE

*** 共享存储
共享存储也成为共享内存，和其他XSI IPC一样也每个共享存储段也有一个结构
#+BEGIN_SRC C++
#include <sys/shm.h>
/* Data structure describing a set of semaphores.  */
struct shmid_ds
  {
    struct ipc_perm shm_perm;		/* operation permission struct */
    size_t shm_segsz;			/* size of segment in bytes */
    __time_t shm_atime;			/* time of last shmat() */
    unsigned long int __unused1;
    __time_t shm_dtime;			/* time of last shmdt() */
    unsigned long int __unused2;
    __time_t shm_ctime;			/* time of last change by shmctl() */
    unsigned long int __unused3;
    __pid_t shm_cpid;			/* pid of creator */
    __pid_t shm_lpid;			/* pid of last shmop */
    shmatt_t shm_nattch;		/* number of current attaches */
    unsigned long int __unused4;
    unsigned long int __unused5;
  };
#+END_SRC

关于共享存储的接口如下：
#+BEGIN_SRC C++
/* The following System V style IPC functions implement a shared memory
   facility.  The definition is found in XPG4.2.  */

/* Shared memory control operation.  */
extern int shmctl (int __shmid, int __cmd, struct shmid_ds *__buf) __THROW;

/* Get shared memory segment.  */
extern int shmget (key_t __key, size_t __size, int __shmflg) __THROW;

/* Attach shared memory segment.  */
extern void *shmat (int __shmid, __const void *__shmaddr, int __shmflg)
     __THROW;

/* Detach shared memory segment.  */
extern int shmdt (__const void *__shmaddr) __THROW;
#+END_SRC
首先我们通过shmget来获得一个共享内存标识符，size这个字段表示共享存储大小内部会和PAGE_SIZE对齐。
然后调用shmctl来操作这个共享内存包括IPC_STAT,IPC_SET以及IPC_RMID.如果进程需要连接到这个共享内存段的话，
可以调用shmat,flag有下面这些选项：
   - SHM_RND.如果addr不为0的话，那么会将addr向下取地址为SHMLBA的平方
   - SHM_RDONLY.只读的共享内存段
如果不想连接这个共享内存段的话，那么可以直接shmdt.这个时候shmid_ds里面的shm_nattch字段会-1.

相对来说，共享内存是最好理解的IPC了，是一种非常自然的概念。
#+BEGIN_SRC C++
#include <unistd.h>
#include <sys/shm.h>
#include <sys/wait.h>
#include <cstdio>
#include <cstring>

int main(){
    printf("SHMLBA(shared memory low boundary):%d\n",SHMLBA);
    int shmid=shmget(IPC_PRIVATE,1024,0666);
    pid_t pid=fork();
    if(pid==0){//child
        sleep(2);
        char* addr=(char*)shmat(shmid,0,0);
        printf("%s\n",addr);
        shmid_ds buf;
        shmctl(shmid,IPC_STAT,&buf);
        printf("segment size:%d,attach number:%d\n",buf.shm_segsz,buf.shm_nattch);
        return 0;
    }
    char* addr=(char*)shmat(shmid,0,0);
    strcpy(addr,"hello,world");
    wait(NULL);
    return 0;
}
#+END_SRC
#+BEGIN_EXAMPLE
[dirlt@localhost.localdomain]$ ./a.out
SHMLBA(shared memory low boundary):4096
hello,world
segment size:1024,attach number:2
#+END_EXAMPLE

*** mmap共享内存
如果仅仅是父子进程之间的共享内存的话，那么可以有更加简单的方式，都和mmap相关。第一种方式是将
mmap映射/dev/zero这个文件。因为/dev/zero是一个特殊文件任何写都被忽略，并且一旦映射上的话存储
区内容都被初始化为0.另外一种方式是简化的方式，Linux系统提供了MAP_ANON选项使用这个选项的话，那么不需要
打开/dev/zero就可以创建一个具有进程关系之间的匿名存储映射。
#+BEGIN_SRC C++
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <cstdio>
#include <cstring>

int main(){
    int fd=open("/dev/zero",O_RDWR);
    char* addr=(char*)mmap(0,1024,PROT_READ | PROT_WRITE,MAP_SHARED,fd,0);
    close(fd);
    if(fork()==0){//child
        sleep(1);
        printf("%s\n",addr);
        munmap(addr,1024);
        return 0;
    }
    strcpy(addr,"hello");
    wait(NULL);
    munmap(addr,1024);
    return 0;
}
#+END_SRC

#+BEGIN_SRC C++
#include <unistd.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <cstdio>
#include <cstring>

int main(){
    char* addr=(char*)mmap(0,1024,PROT_READ | PROT_WRITE,MAP_SHARED | MAP_ANON,-1,0);
    if(fork()==0){//child
        sleep(1);
        printf("%s\n",addr);
        munmap(addr,1024);
        return 0;
    }
    strcpy(addr,"hello");
    wait(NULL);
    munmap(addr,1024);
    return 0;
}
#+END_SRC
使用mmap相对于使用IPC共享内存来说，使用更加方便简单，但是只允许是在有进程关系之间进程使用。

*** 进程pthread锁
pthread的同步机制允许设置进程之间的共享属性。通过pthread的同步机制是在共享内存上面开辟并且设置了共享属性，
那么就允许pthread来协调进程之间的同步。

#+BEGIN_SRC C++
#include <unistd.h>
#include <pthread.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <cstdio>
#include <cstring>

int main(){
    void* addr=(void*)mmap(0,1024,PROT_READ | PROT_WRITE,MAP_SHARED | MAP_ANON,-1,0);
    //在共享内存上面开辟出互斥锁和条件变量
    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_setpshared(&attr,1);
    pthread_mutex_t* mutex=(pthread_mutex_t*)addr;
    pthread_mutex_init(mutex,&attr);

    pthread_condattr_t attr2;
    pthread_condattr_init(&attr2);
    pthread_condattr_setpshared(&attr2,1);
    pthread_cond_t* cond=(pthread_cond_t*)((char*)addr+sizeof(pthread_mutex_t));
    pthread_cond_init(cond,&attr2);

    if(fork()==0){//child
        printf("child wait to exit\n");
        pthread_mutex_lock(mutex);
        pthread_cond_wait(cond,mutex);
        pthread_mutex_unlock(mutex);
        printf("child about to exit\n");
        munmap(addr,1024);
        return 0;
    }
    sleep(1);
    pthread_cond_signal(cond);
    printf("parent waiting\n");
    wait(NULL);
    //fini.只需要销毁一次
    int err=0;
    err=pthread_mutex_destroy(mutex);
    if(err!=0){
        printf("mutex destroy:%s\n",strerror(err));
    }
    err=pthread_cond_destroy(cond);
    if(err!=0){
        printf("cond destroy:%s\n",strerror(err));
    }
    munmap(addr,1024);
    return 0;
}
#+END_SRC

#+BEGIN_EXAMPLE
[dirlt@localhost.localdomain]$ ./a.out
child wait to exit
parent waiting
child about to exit
#+END_EXAMPLE
